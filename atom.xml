<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞翔的傻瓜</title>
  
  <subtitle>菜鸟的试飞之旅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jzygaga.github.io/"/>
  <updated>2019-01-13T09:16:05.682Z</updated>
  <id>https://jzygaga.github.io/</id>
  
  <author>
    <name>FlyingFool</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Non-decreasing Array</title>
    <link href="https://jzygaga.github.io/2019/01/13/leetocde-665.%20Non-decreasing%20Array/"/>
    <id>https://jzygaga.github.io/2019/01/13/leetocde-665. Non-decreasing Array/</id>
    <published>2019-01-13T09:06:29.000Z</published>
    <updated>2019-01-13T09:16:05.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="665-Non-decreasing-Array"><a href="#665-Non-decreasing-Array" class="headerlink" title="665. Non-decreasing Array"></a>665. Non-decreasing Array</h2><ul><li><strong>问题描述：</strong><br>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.<br>We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). </li><li><p><strong>Example 1:</strong><br>Input: [4,2,3]<br>Output: True<br>Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</p><pre><code>class Solution {    public boolean checkPossibility(int[] nums) {            int modifyCount = 0;            for(int i = 1; i &lt; nums.length; i++) {                if(nums[i - 1] &gt; nums[i]) {                    modifyCount++;                    if(modifyCount&gt;1)                        return false;                    if(i - 2 &gt;= 0 &amp;&amp; nums[i - 2] &gt; nums[i]) {                        nums[i] = nums[i - 1];                    } else {                        nums[i - 1] = nums[i];                    }                }            }            return true;        }    }</code></pre><p><a href="http://www.cnblogs.com/grandyang/p/7565424.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/7565424.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;665-Non-decreasing-Array&quot;&gt;&lt;a href=&quot;#665-Non-decreasing-Array&quot; class=&quot;headerlink&quot; title=&quot;665. Non-decreasing Array&quot;&gt;&lt;/a&gt;665. Non-decr
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis之（一）初识Redis</title>
    <link href="https://jzygaga.github.io/2019/01/12/Redis%E4%B9%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E8%AF%86Redis/"/>
    <id>https://jzygaga.github.io/2019/01/12/Redis之（一）初识Redis/</id>
    <published>2019-01-12T07:56:21.000Z</published>
    <updated>2019-01-13T05:50:17.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Redis概述"><a href="#1、Redis概述" class="headerlink" title="1、Redis概述"></a>1、Redis概述</h2><p>我们知道，内存是电脑主板上的存储部件，用于存储当前正在使用的数据和程序，CPU可以与内存直接沟通，所以访问速速非常高；而外存数据必须加载到内存以后程序才能使用。如果把CPU当做一个吃货，那么内存是碗，而外存是锅，这个吃货再能吃，也得先把饭从锅里盛到碗里再下嘴，而不能直接跳到锅里大快朵颐。但是很多时候CPU吃的并不爽，一是因为碗不够大，没吃两嘴就没了；二是从锅里往碗里盛饭是个比较耗时的过程，等待很痛苦。正经点说，就是内存大小、I/O速度、网络响应时间等常常成为应用系统的性能瓶颈。</p><p>传统的关系型数据库如MySQL、Oracle、DB2等，数据存储在磁盘的文件系统中，增删改查需要频繁地在内存与外存之间交换数据，很费时间。试想，如果有一种小巧而功能强大的存储结构，<strong>用于在内存中管理数据量不太大但是访问量特别大的热点数据</strong>。<br>在以上背景下，Redis应运而生。</p><p>Redis是Remote Dictionary Server的简称，是一个由意大利人Salvatore Sanfilippo开发的key-value存储系统，具有极高的读写性能，读的速度可达110000次/s，写的速度可达81000次/s 。</p><p>与Redis类似的产品还有memcache，同样是一个基于内存的key-value存储系统，但是由于memcache数据结构单一，数据安全性低下等原因，大有被Redis取而代之的趋势。</p><p>Redis 与其他 key - value 缓存产品相比，有以下特点：</p><ol><li><p>Redis支持数据的持久化，周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，重启的时候可以再次加载进行使用。</p></li><li><p>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p></li><li><p>Redis支持数据的备份，即master-slave模式的数据备份。</p></li><li><p>Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</p></li><li><p>Redis还支持 publish/subscribe, 通知, key过期等高级特性。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、Redis概述&quot;&gt;&lt;a href=&quot;#1、Redis概述&quot; class=&quot;headerlink&quot; title=&quot;1、Redis概述&quot;&gt;&lt;/a&gt;1、Redis概述&lt;/h2&gt;&lt;p&gt;我们知道，内存是电脑主板上的存储部件，用于存储当前正在使用的数据和程序，CPU可以与
      
    
    </summary>
    
      <category term="Redis" scheme="https://jzygaga.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://jzygaga.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>python的枚举</title>
    <link href="https://jzygaga.github.io/2019/01/09/%E5%87%86%E5%A4%87%E7%BC%96%E8%BE%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://jzygaga.github.io/2019/01/09/准备编辑的博客/</id>
    <published>2019-01-09T13:56:56.000Z</published>
    <updated>2019-01-09T13:59:40.615Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python的枚举"><a href="#python的枚举" class="headerlink" title="python的枚举"></a>python的枚举</h2><ul><li>python的枚举类不允许有相同的元素，元素的值不允许修改。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python的枚举&quot;&gt;&lt;a href=&quot;#python的枚举&quot; class=&quot;headerlink&quot; title=&quot;python的枚举&quot;&gt;&lt;/a&gt;python的枚举&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;python的枚举类不允许有相同的元素，元素的值不允许修改。&lt;/li&gt;

      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>准备编辑的博客</title>
    <link href="https://jzygaga.github.io/2019/01/09/java-Json/"/>
    <id>https://jzygaga.github.io/2019/01/09/java-Json/</id>
    <published>2019-01-09T08:42:03.000Z</published>
    <updated>2019-01-09T13:55:22.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON简介绍"><a href="#JSON简介绍" class="headerlink" title="JSON简介绍"></a>JSON简介绍</h3><ul><li>JSON 英语的全写 JavaScript Object Notation<br>javaScript 对象标记</li><li>JSON是一个轻量级的数据格式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h2&gt;&lt;h3 id=&quot;JSON简介绍&quot;&gt;&lt;a href=&quot;#JSON简介绍&quot; class=&quot;headerlink&quot; title=&quot;JSO
      
    
    </summary>
    
      <category term="java" scheme="https://jzygaga.github.io/categories/java/"/>
    
    
      <category term="JSON" scheme="https://jzygaga.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>python的正则表达式</title>
    <link href="https://jzygaga.github.io/2019/01/09/python-3%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cjson/"/>
    <id>https://jzygaga.github.io/2019/01/09/python-3的正则表达式和json/</id>
    <published>2019-01-09T07:47:46.000Z</published>
    <updated>2019-01-09T07:59:14.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre><code>import relanguage = &apos;PythonC#JavaC#PHPC#&apos;def convert(value):    match = value.group()    return &apos;!!&apos;+match+&apos;!!&apos;r = re.sub(&apos;C#&apos;, convert, language)print(r)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;import re

language = &amp;apos;PythonC#JavaC#PHPC#&amp;ap
      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python的赋值</title>
    <link href="https://jzygaga.github.io/2019/01/08/python-2%E8%B5%8B%E5%80%BC/"/>
    <id>https://jzygaga.github.io/2019/01/08/python-2赋值/</id>
    <published>2019-01-08T06:47:52.000Z</published>
    <updated>2019-01-08T07:05:15.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python的赋值"><a href="#python的赋值" class="headerlink" title="python的赋值"></a>python的赋值</h3><ul><li>int str tuple （不可改变）的值类型</li><li>list set dict（可改变） 的引用类型</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python的赋值&quot;&gt;&lt;a href=&quot;#python的赋值&quot; class=&quot;headerlink&quot; title=&quot;python的赋值&quot;&gt;&lt;/a&gt;python的赋值&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;int str tuple （不可改变）的值类型&lt;/li&gt;
&lt;li&gt;li
      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python入门</title>
    <link href="https://jzygaga.github.io/2019/01/07/python-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://jzygaga.github.io/2019/01/07/python-1数据类型/</id>
    <published>2019-01-07T13:50:37.000Z</published>
    <updated>2019-01-08T06:37:00.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h2><h3 id="python的数据类型"><a href="#python的数据类型" class="headerlink" title="python的数据类型"></a>python的数据类型</h3><p>type(1<em>1)<br>class ‘int’<br>type(1</em>1.0)<br>class ‘float’<br>type(2/2)<br>class ‘float’<br>type(2//2)<br>class ‘int’<br><strong>双斜杠是除完然后取整。</strong></p><h3 id="python的进制"><a href="#python的进制" class="headerlink" title="python的进制"></a>python的进制</h3><ul><li>0b表示二进制<br>0b11-&gt;3<br>0b10-&gt;2</li><li>0o表示8进制<br>0o10-&gt;8<br>0o11-&gt;9</li><li>0x表示16进制<br>0x10-&gt;16<br>0x11-&gt;17</li><li>bin（）方法完成其他进制转换成二进制</li><li>int（）方法将其他进制转换成十进制</li><li>hex（）方法将其他进制转换成16进制</li><li>oct（）方法将其他进制转换成8进制</li></ul><h3 id="python的bool的类型"><a href="#python的bool的类型" class="headerlink" title="python的bool的类型"></a>python的bool的类型</h3><ul><li>bool(1） true</li><li>bool(2)  true</li><li>bool(3)  true</li><li>bool(0)  false</li></ul><h3 id="python中为什么有单双引号"><a href="#python中为什么有单双引号" class="headerlink" title="python中为什么有单双引号"></a>python中为什么有单双引号</h3><ol><li>“let us go”</li><li>‘let us go’</li><li>“let’s go”</li><li>“let’s go”</li><li>“let\’s go”</li><li>“let’s go”</li></ol><ul><li>单双引号换行<ul><li>‘hello\world’,</li><li>“””hello world “””</li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li>“hello world”[0:-2]<br>‘hello wor’</li><li>“hello world”[1]<br>‘e’</li><li>“hello world”[2]<br>‘l’</li><li>“hello world”[3]<br>‘l’</li><li>“hello world”[4]<br>‘o’</li><li>r’dfdfdf’或者R’dfdfdffd’原始字符串<h3 id="python中的列表"><a href="#python中的列表" class="headerlink" title="python中的列表"></a>python中的列表</h3></li></ol><ul><li>list里面可以存放任意类型<br>1.输出：[1, 2, 3, ‘1’, True, False]<br> 结果：[1,2,3,’1’,True,False]</li><li>list里面读取字符</li></ul><ol><li>[“第一技能”,”第二季能”,”第三季能”,”第四技能”][1:3]<br> [‘第二季能’, ‘第三季能’]</li></ol><ul><li>list添加元素<br>[“第一技能”,”第二季能”,”第三季能”,”第四技能”]+[“点燃”,”虚弱”]</li></ul><h3 id="python中的元组"><a href="#python中的元组" class="headerlink" title="python中的元组"></a>python中的元组</h3><p>-表示形式</p><ol><li>>&gt;&gt; (1,2,3,4,5)<pre><code>(1, 2, 3, 4, 5)</code></pre></li><li>>&gt;&gt; type((1,2,3,4,5))<pre><code>&lt;class &apos;tuple&apos;&gt;</code></pre></li></ol><ul><li>对于只含有一个元素的元组</li></ul><ol><li>>&gt;&gt; type((1))<pre><code>&lt;class &apos;int&apos;&gt;</code></pre></li><li>>&gt;&gt; type((‘1’))<pre><code>&lt;class &apos;str&apos;&gt;</code></pre></li><li>>&gt;&gt; type((‘False’))<pre><code>&lt;class &apos;str&apos;&gt;</code></pre></li><li>>&gt;&gt; type((False))<pre><code>&lt;class &apos;bool&apos;&gt;</code></pre><strong>对于一个元素的元组，python会把他当成一个数学运算。</strong></li></ol><p><strong>元组，序列，列表都称之为序列</strong></p><h3 id="python中的序列"><a href="#python中的序列" class="headerlink" title="python中的序列"></a>python中的序列</h3><ol><li>判断是否有元素在里面<br>>&gt;&gt; 3 in [1,2,3,4,5,6]<br>True<br>>&gt;&gt; 3 not in [1,2,3,4,5,6]<br>False</li><li>对元组进行判断<ol><li>>&gt;&gt; len([1,3,5,4,6,8])<br>6</li><li>>&gt;&gt; max([1,3,5,4,6,8])<br>8</li><li>>&gt;&gt; min([1,3,5,4,6,8])<br>1</li><li>>&gt;&gt; min(‘helloword’)<br>‘d’</li><li>>&gt;&gt; max(‘helloword’)<br>‘w’</li></ol></li><li>用ord（’’）读取ascall值<ol><li>>&gt;&gt; ord(‘ ‘)<br>32</li><li>>&gt;&gt; ord(‘w’)<br>119</li><li>>&gt;&gt; ord(‘r’)<br>114</li></ol></li></ol><h3 id="python中的集合"><a href="#python中的集合" class="headerlink" title="python中的集合"></a>python中的集合</h3><ul><li>集合是无序的，所以他没有序列的</li><li><p>集合具有不重复性</p></li><li><p>>&gt;&gt; {1,2,3,4,4,5,6}<br>  {1, 2, 3, 4, 5, 6}</p></li><li>>&gt;&gt; len({1,2,3,4,5})<br>5</li><li>>&gt;&gt; 1 in {1,2,3,4}<br>True</li><li>>&gt;&gt; 1 not in {1,2,3,4}<br>False</li><li>>&gt;&gt; {1,2,3,4,5,6}-{1,2}<br>{3, 4, 5, 6}</li><li>>&gt;&gt; {1,2,3,4,5,6}&amp;{3,4}<br>{3, 4}</li><li>>&gt;&gt; {1,2,3,4,5,6}|{3,4,7}<br>{1, 2, 3, 4, 5, 6, 7}</li><li>>&gt;&gt; type({})<br>class ‘dict’</li><li>>&gt;&gt; type(set())<br>class ‘set’</li><li>>&gt;&gt; len(set())<br>0</li></ul><h3 id="python中的字典"><a href="#python中的字典" class="headerlink" title="python中的字典"></a>python中的字典</h3><ul><li>字典 key-value</li></ul><ol><li>>&gt;&gt; {‘Q’:’新月打击’,’W’:’苍白值瀑’,’E’:’月之降临’,’R’:’月神冲刺’}[‘Q’]<br>‘新月打击’</li></ol><ul><li>value可以是任意类型，key是只能唯一的基本类型。<br><img src="https://i.imgur.com/B1nzF66.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一行代码&quot;&gt;&lt;a href=&quot;#第一行代码&quot; class=&quot;headerlink&quot; title=&quot;第一行代码&quot;&gt;&lt;/a&gt;第一行代码&lt;/h2&gt;&lt;h3 id=&quot;python的数据类型&quot;&gt;&lt;a href=&quot;#python的数据类型&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>快速过桥</title>
    <link href="https://jzygaga.github.io/2019/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%BF%AB%E9%80%9F%E8%BF%87%E6%A1%A5/"/>
    <id>https://jzygaga.github.io/2019/01/07/蓝桥杯-快速过桥/</id>
    <published>2019-01-07T03:41:51.000Z</published>
    <updated>2019-01-07T04:55:10.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速过桥"><a href="#快速过桥" class="headerlink" title="快速过桥"></a>快速过桥</h2><ul><li><strong>问题描述：</strong>n个人的队伍想在晚上通过一座大桥。任何时间最多有2人通过，每组必须有一个手电筒。很可怜，这n个人只有一个手电筒可用，因此必须合理地安排，让手电筒能回到另一端，这样才能让更多人通过大桥。每个人有不同的速度，编组后，一个组的速度等于慢的那个人的速度。你的任务是实现一种策略，让所有人在最短时间内通过。</li><li><strong>样例输入</strong><br>【样例输入】<br>  1<br>  4<br>  1<br>  2<br>  5<br>  10<br>【样例输出】<br>  17<br>  1 2<br>  1<br>  5 10<br>  2<br>  1 2</li><li><a href="https://blog.csdn.net/qq_41061455/article/details/79536991" target="_blank" rel="noopener">https://blog.csdn.net/qq_41061455/article/details/79536991</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速过桥&quot;&gt;&lt;a href=&quot;#快速过桥&quot; class=&quot;headerlink&quot; title=&quot;快速过桥&quot;&gt;&lt;/a&gt;快速过桥&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;n个人的队伍想在晚上通过一座大桥。任何时间最多有2人通过，每组必须有
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://jzygaga.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="智力题" scheme="https://jzygaga.github.io/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://jzygaga.github.io/2019/01/06/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://jzygaga.github.io/2019/01/06/剑指offer-斐波那契数列/</id>
    <published>2019-01-06T06:34:09.000Z</published>
    <updated>2019-01-06T09:37:25.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><ul><li>描述<br><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 </strong></li><li>代码<pre><code>public int Fibonacci1(int n) {      if(n==1)          return 1;      if(n==2)          return 1;        int[] arr=new int[n];        arr[0]=1;        arr[1]=1;        for(int i=2;i&lt;n;i++) {            arr[i]=arr[i-1]+arr[i-2];        }        return arr[n-1];    }</code></pre></li><li><p>代码</p><pre><code>import java.util.HashMap;import java.util.Map;public class Solution {    private Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();    public int Fibonacci(int n) {         if(n==1)           return 1;         if(n==2)          return 1;         if(map.get(n)!=null)             return map.get(n);        map.put(n, Fibonacci(n-1)+Fibonacci(n-2));        return map.get(n);    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;描述&lt;br&gt;&lt;strong&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Powerful Integers</title>
    <link href="https://jzygaga.github.io/2019/01/06/leetcode-970.%20Powerful%20Integers/"/>
    <id>https://jzygaga.github.io/2019/01/06/leetcode-970. Powerful Integers/</id>
    <published>2019-01-06T05:57:10.000Z</published>
    <updated>2019-01-06T06:09:29.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="970-Powerful-Integers"><a href="#970-Powerful-Integers" class="headerlink" title="970. Powerful Integers"></a>970. Powerful Integers</h2><ul><li><strong>描述：</strong>Given two non-negative integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &gt;= 0 and j &gt;= 0.</li><li>例子<ul><li>例子1<br>   Input: x = 2, y = 3, bound = 10<pre><code>Output: [2,3,4,5,7,9,10]Explanation: 2 = 2^0 + 3^03 = 2^1 + 3^04 = 2^0 + 3^15 = 2^1 + 3^17 = 2^2 + 3^19 = 2^3 + 3^010 = 2^0 + 3^2</code></pre></li></ul></li><li><p>代码</p><ul><li><p>while</p><pre><code>class Solution {      public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) {         int maxV=Math.max(x, y);         int minV=Math.min(x, y);         int sum;         int sumMaxV=1;         int sumMinV=1;        Set&lt;Integer&gt; set=new HashSet&lt;&gt;();        //3         while(sumMaxV&lt;=bound) {             sumMinV=1;             while(sumMinV&lt;=(bound-sumMaxV)) {                 sum=sumMaxV+sumMinV;                // if(sum&gt;bound)                //     break;     while()条件已经判断了                 set.add(sum);               if(minV==1)                     break;                 sumMinV*=minV;             }             sumMaxV*=maxV;              if(maxV==1)                     break;         }         return new ArrayList&lt;&gt;(set);     }}</code></pre></li><li><p>for</p><pre><code>    public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) {        Set&lt;Integer&gt; result = new HashSet&lt;&gt;();        for (int a = 1; a &lt; bound; a *= x) {            for (int b = 1; a + b &lt;= bound; b *= y) {                result.add(a + b);                if (y == 1) {                    break;                }            }            if (x == 1) {                break;            }        }        return new ArrayList&lt;&gt;(result);    }}</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;970-Powerful-Integers&quot;&gt;&lt;a href=&quot;#970-Powerful-Integers&quot; class=&quot;headerlink&quot; title=&quot;970. Powerful Integers&quot;&gt;&lt;/a&gt;970. Powerful Integers
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>图结构</title>
    <link href="https://jzygaga.github.io/2019/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>https://jzygaga.github.io/2019/01/05/数据结构-图/</id>
    <published>2019-01-05T03:01:15.000Z</published>
    <updated>2019-01-05T13:36:37.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><ul><li>图的分类<ul><li>有向图，无向图<ul><li>边上有方向</li><li>边上无方向</li></ul></li><li>有权图，无权图<ul><li>有权图，边上有值。</li><li>无权图，边上无值。</li></ul></li></ul></li><li>图的连通性<ul><li>判断图之间是否连通</li><li>连通分量</li></ul></li><li>边<ul><li>自环边</li><li>平行边<br><img src="https://i.imgur.com/MoWEPbr.png" alt=""></li></ul></li></ul><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><ul><li><p>邻接矩阵<br><img src="https://i.imgur.com/TcAYKKm.png" alt=""></p><pre><code>package graphic;    /**     * 密集矩阵用邻接矩阵     * @author 59842     *     */    public class DenseGraph {        //有多少个定点        private int n;        //有多少个边        private int m;        //是否有向//true表示有向图        private boolean directed;        //存储图的有向结构        private boolean[][] g;        public DenseGraph(int n, boolean directed) {            this.n=n;            this.m=0;            this.directed=directed;            g=new boolean [n][n];        }        public void addEdge(int v,int w) {            if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n)                throw new IllegalArgumentException(&quot;边超出了范围&quot;);            if(hasEdge(v,w))                return ;            g[v][w]=true;            if(!directed)                //不是有向图                g[w][v]=true;            m++;        }        private boolean hasEdge(int v, int w) {            if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n)                throw new IllegalArgumentException(&quot;边超出了范围&quot;);            return g[w][v]=false;        }        public int getV() {            return n;        }        public int getE() {            return m;        }    }</code></pre></li><li><p>邻接表<br><img src="https://i.imgur.com/IOng9e6.png" alt=""></p></li><li><p>完全图</p><ul><li>适用的场景，每个电影的相似程度。有权图<br><strong>邻接表适合表示稀疏图，邻接矩阵适合表示稠密图</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图结构&quot;&gt;&lt;a href=&quot;#图结构&quot; class=&quot;headerlink&quot; title=&quot;图结构&quot;&gt;&lt;/a&gt;图结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;图的分类&lt;ul&gt;
&lt;li&gt;有向图，无向图&lt;ul&gt;
&lt;li&gt;边上有方向&lt;/li&gt;
&lt;li&gt;边上无方向&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="图结构" scheme="https://jzygaga.github.io/categories/%E5%9B%BE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://jzygaga.github.io/2019/01/04/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://jzygaga.github.io/2019/01/04/剑指offer-用两个栈实现队列/</id>
    <published>2019-01-04T03:08:18.000Z</published>
    <updated>2019-01-04T03:13:44.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong></p><ul><li><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><ul><li><p>自己解</p><pre><code>import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();     public void push(int node) {           stack1.push(node);    }    public int pop() {        while(!stack1.isEmpty()) {            stack2.push(stack1.pop());        }        Integer toPop = stack2.pop();        while(!stack2.isEmpty()) {            stack1.push(stack2.pop());        }        return toPop;    }}</code></pre></li><li><p>渐优解</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自己解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Stac
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://jzygaga.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://jzygaga.github.io/2019/01/04/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://jzygaga.github.io/2019/01/04/剑指offer-重建二叉树/</id>
    <published>2019-01-04T02:47:53.000Z</published>
    <updated>2019-01-04T02:52:54.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>题目描述</strong></p><ul><li><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><pre><code>/** * Definition for binary tree * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {     public TreeNode reConstructBinaryTree(int [] pre,int [] in) {        if(pre==null||in==null||pre.length!=in.length)            return null;       return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);    }    private TreeNode reConstructBinaryTree(int[] pre,int pStart,int pEnd,int[] in,int iStart,int iEnd){        //一般性问题        if(pStart&gt;pEnd)            return null;        //创建根节点        TreeNode root=new TreeNode(pre[pStart]);        //找到中序遍历中的位置        int loc;        for(loc=0;loc&lt;in.length;loc++){            if(in[loc]==pre[pStart]){                break;            }        }        //计算左右子树节点的个数。        int len=loc-iStart;        root.left=reConstructBinaryTree(pre,pStart+1,pStart+len,in,iStart,iStart+len-1);        root.right=reConstructBinaryTree(pre,pStart+len+1,pEnd,in,iStart+len+1,iEnd);        return root;    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重建二叉树&quot;&gt;&lt;a href=&quot;#重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;重建二叉树&quot;&gt;&lt;/a&gt;重建二叉树&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://jzygaga.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>234. Palindrome Linked List</title>
    <link href="https://jzygaga.github.io/2019/01/03/leetcode-%E5%8D%95%E9%93%BE%E8%A1%A8-234.%20Palindrome%20Linked%20List/"/>
    <id>https://jzygaga.github.io/2019/01/03/leetcode-单链表-234. Palindrome Linked List/</id>
    <published>2019-01-03T06:32:36.000Z</published>
    <updated>2019-01-03T06:38:51.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a>Palindrome Linked List</h2><ul><li>描述：<strong>Given a singly linked list, determine if it is a palindrome.</strong></li><li>例子：<ul><li>Input: 1-&gt;2 ，Output: false </li><li>Input: 1-&gt;2-&gt;2-&gt;1，Output: true</li></ul></li></ul><p><strong>代码1</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Palindrome-Linked-List&quot;&gt;&lt;a href=&quot;#Palindrome-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Palindrome Linked List&quot;&gt;&lt;/a&gt;Palindrome Linked Li
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="单链表" scheme="https://jzygaga.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="https://jzygaga.github.io/2019/01/03/leetcode-206.%20Reverse%20Linked%20List/"/>
    <id>https://jzygaga.github.io/2019/01/03/leetcode-206. Reverse Linked List/</id>
    <published>2019-01-03T04:18:55.000Z</published>
    <updated>2019-01-03T05:51:01.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h2><p><strong>Reverse a singly linked list.</strong><br><strong> Example:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>代码</strong></p><ul><li><p>迭代的代码</p><pre><code>class Solution {     public ListNode reverseList(ListNode head) {        ListNode reverseNode=null;        ListNode cur=head;        ListNode toDeal=null;        while(cur!=null) {            //拿到待处理的节点            toDeal =cur;            cur=cur.next;            //拿到一边进行连接            toDeal.next=reverseNode;            reverseNode=toDeal;        }        return reverseNode;    }}</code></pre></li></ul><ul><li><p>递归的代码<br><strong>代码一</strong></p><pre><code>class Solution {     public ListNode reverseList(ListNode head) {        if(head==null||head.next==null)            return head;        return toReverse(head,null);    }    private ListNode toReverse(ListNode head, ListNode reverse) {        if(head==null) {            return reverse;        }        ListNode cur=head.next;        //与另一个链表相连接        head.next=reverse;        //        reverse=head;        return toReverse(cur,reverse);    }}</code></pre></li></ul><p><strong>代码二</strong></p><pre><code>public ListNode reverseList(ListNode head) {    if(head==null||head.next==null)        return head;    ListNode newHead= reverseList(head.next);    //两个借点之间的链接进行翻转    head.next.next=head;    head.next=null;    return newHead;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Reverse Linked List&quot;&gt;&lt;/a&gt;Reverse Linked List&lt;/h2&gt;&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="链表" scheme="https://jzygaga.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Middle of the Linked List</title>
    <link href="https://jzygaga.github.io/2019/01/03/leetcode-876.%20Middle%20of%20the%20Linked%20List/"/>
    <id>https://jzygaga.github.io/2019/01/03/leetcode-876. Middle of the Linked List/</id>
    <published>2019-01-02T22:05:24.000Z</published>
    <updated>2019-01-02T22:54:08.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876. Middle of the Linked List"></a>876. Middle of the Linked List</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><strong> Given a non-empty, singly linked list with head node head, return a middle node of linked list.<br>if there are two middle nodes, return the second middle node. </strong></p><ul><li>Example 1:<br>  Input: [1,2,3,4,5]<br>  Output: Node 3 from this list (Serialization: [3,4,5])<br>  The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>  Note that we returned a ListNode object ans, such that:<br>  ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</li><li><p>Example 2：<br>  Input: [1,2,3,4,5]<br>  Output: Node 3 from this list (Serialization: [3,4,5])<br>  The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>  Note that we returned a ListNode object ans, such that:<br>  ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</p><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><pre><code>    class Solution {    public ListNode middleNode(ListNode head) {        ListNode node=head;        int i=0;        while(node!=null) {             i++;             node=node.next;        }        int loc=i/2+1;        i=1;        ListNode node1=head;        while(i&lt;loc) {            node1=node1.next;            i++;        }        return node1;    }}</code></pre><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><pre><code>public ListNode middleNode(ListNode head) {    ListNode listNode = new ListNode(0);    ListNode fast=head;    ListNode low=head;    while(fast!=null&amp;&amp;fast.next!=null) {        fast=fast.next.next;        low=low.next;    }    return low.next;}</code></pre><h3 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a>代码三</h3><pre><code>  class Solution {    public ListNode middleNode(ListNode head) {        ListNode fast=head;        ListNode low=head;        //对比2方法，假装自己先跑了两步         if(fast!=null&amp;&amp;fast.next!=null){            fast=fast.next.next;        }else{            return low;        }        while(fast!=null&amp;&amp;fast.next!=null) {            fast=fast.next.next;            low=low.next;        }        return low.next;    }}</code></pre><h3 id="代码四"><a href="#代码四" class="headerlink" title="代码四"></a>代码四</h3><pre><code>public ListNode middleNode(ListNode head) {    ListNode fast=head;    ListNode low=head;    //对比2方法，假装自己先跑了两步    if(head==null&amp;&amp;head.next==null)        return head;    while(fast!=null&amp;&amp;fast.next!=null) {        fast=fast.next.next;        low=low.next;    }    return low;}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;876-Middle-of-the-Linked-List&quot;&gt;&lt;a href=&quot;#876-Middle-of-the-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;876. Middle of the Linked List&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="链表" scheme="https://jzygaga.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://jzygaga.github.io/2019/01/02/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%20/"/>
    <id>https://jzygaga.github.io/2019/01/02/剑指offer-二维数组中的查找 /</id>
    <published>2019-01-02T06:19:14.000Z</published>
    <updated>2019-01-03T08:21:57.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>描述：</strong></p><ul><li><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>代码</strong></p><pre><code>public class Solution {    public boolean Find(int target, int [][] array) {        int y=0;        int x=array.length-1;        int row=array.length-1;        int col=array[0].length-1;        while((0&lt;=x&amp;&amp;x&lt;=col)&amp;&amp;(0&lt;=y&amp;&amp;y&lt;=row)){            if(array[x][y]==target)                return true;            if(array[x][y]&lt;target){                y++;               continue;             }            if(array[x][y]&gt;target){                x--;               continue;            }        }        return false;    }}</code></pre><h2 id="注意数组根据先后赋值，排列是从上到下来的"><a href="#注意数组根据先后赋值，排列是从上到下来的" class="headerlink" title="注意数组根据先后赋值，排列是从上到下来的"></a>注意数组根据先后赋值，排列是从上到下来的</h2></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个二维数组中（
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://jzygaga.github.io/2019/01/02/java-%E5%8F%8D%E5%B0%84/"/>
    <id>https://jzygaga.github.io/2019/01/02/java-反射/</id>
    <published>2019-01-02T05:34:53.000Z</published>
    <updated>2019-01-02T06:16:14.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对方的付费"><a href="#对方的付费" class="headerlink" title="对方的付费"></a>对方的付费</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对方的付费&quot;&gt;&lt;a href=&quot;#对方的付费&quot; class=&quot;headerlink&quot; title=&quot;对方的付费&quot;&gt;&lt;/a&gt;对方的付费&lt;/h2&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://jzygaga.github.io/categories/java/"/>
    
    
      <category term="反射" scheme="https://jzygaga.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jzygaga.github.io/2019/01/01/设计模式-代理模式/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T05:15:53.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="https://jzygaga.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="代理模式" scheme="https://jzygaga.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E4%BA%A7%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jzygaga.github.io/2019/01/01/设计模式-工产模式/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T05:10:24.762Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="https://jzygaga.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂模式" scheme="https://jzygaga.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
