<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞翔的傻瓜</title>
  
  <subtitle>菜鸟的试飞之旅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jzygaga.github.io/"/>
  <updated>2019-01-02T05:15:53.836Z</updated>
  <id>https://jzygaga.github.io/</id>
  
  <author>
    <name>FlyingFool</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jzygaga.github.io/2019/01/01/设计模式-代理模式/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T05:15:53.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="https://jzygaga.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="代理模式" scheme="https://jzygaga.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E4%BA%A7%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jzygaga.github.io/2019/01/01/设计模式-工产模式/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T05:10:24.762Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="https://jzygaga.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂模式" scheme="https://jzygaga.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL%E6%A0%91/"/>
    <id>https://jzygaga.github.io/2019/01/01/数据结构-AVL树/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T05:38:48.766Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li>平衡二叉树的定义<ul><li>对于任意一个节点，左子树和右子树的高度差不能超过1</li><li>AVL树有着自己的平衡性，所以在自己的增加和删除，不会退化成一个链表</li></ul></li><li>满二叉树<br>   <img src="https://i.imgur.com/vpxDXic.png" width="100" height="100" div="" align="right"><ul><li>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空</li></ul></li><li>AVL<ul><li>定义每一个节点的高度</li><li>计算平衡因子 <ul><li>定义： 每个节点的平衡因子等于左子树减去右子树的差</li><li>作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的<br><img src="https://i.imgur.com/gutLgG7.png" width="200" height="200" div="" align="right"></li></ul></li><li>AVL的左旋转右旋转<ul><li>当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。<br>*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。</li></ul></li></ul></li></ul><pre><code>package AVLTree;import java.util.ArrayList;public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; {    private class Node{        public K key;        public V value;        public Node left, right;        public int height;        public Node(K key, V value){            this.key = key;            this.value = value;            left = null;            right = null;            height = 1;        }    }    private Node root;    private int size;    public AVLTree(){        root = null;        size = 0;    }    public int getSize(){        return size;    }    public boolean isEmpty(){        return size == 0;    }    // 获得节点node的高度    private int getHeight(Node node){        if(node == null)            return 0;        return node.height;    }    // 获得节点node的平衡因子    private int getBalanceFactor(Node node){        if(node == null)            return 0;        return getHeight(node.left) - getHeight(node.right);    }    // 向二分搜索树中添加新的元素(key, value)    public void add(K key, V value){        root = add(root, key, value);    }    // 向以node为根的二分搜索树中插入元素(key, value)，递归算法    // 返回插入新节点后二分搜索树的根    private Node add(Node node, K key, V value){        if(node == null){            size ++;            return new Node(key, value);        }        if(key.compareTo(node.key) &lt; 0)            node.left = add(node.left, key, value);        else if(key.compareTo(node.key) &gt; 0)            node.right = add(node.right, key, value);        else // key.compareTo(node.key) == 0            node.value = value;        // 更新height        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));                 int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0)            return rightRotate(node);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0)            return leftRotate(node);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) {            //先进行左旋            node.left= leftRotate(node.left);            return rightRotate(node);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) {            node.right=rightRotate(node.right);            return leftRotate(node);        }        return node;    }    //对节点进行左旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          T1  x   向右旋转(y),左侧过高不平衡                   y    z    //             / \    ----------------------&gt;               / \   / \    //          T2  z                                     T1 T2 T3 T4    //             / \   //                T4  T3    //    private Node leftRotate(Node y) {        Node x=y.right;        Node T2=x.right;        //向右旋转过程        x.left=y;        y.right=T2;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    //对节点进行右旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          x   T4    向右旋转(y),左侧过高不平衡                   z    y    //         / \      ----------------------&gt;               / \   / \    //      z   T3                                        T1 T2 T3 T4    //     / \    //      T1  T2    // 返回以node为根节点的二分搜索树中，key所在的节点    private Node rightRotate(Node y) {        Node x=y.left;        Node T3=x.right;        //向右旋转过程        x.right=y;        y.left=T3;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    private Node getNode(Node node, K key){        if(node == null)            return null;        if(key.equals(node.key))            return node;        else if(key.compareTo(node.key) &lt; 0)            return getNode(node.left, key);        else // if(key.compareTo(node.key) &gt; 0)            return getNode(node.right, key);    }    public boolean contains(K key){        return getNode(root, key) != null;    }    public V get(K key){        Node node = getNode(root, key);        return node == null ? null : node.value;    }    public void set(K key, V newValue){        Node node = getNode(root, key);        if(node == null)            throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;);        node.value = newValue;    }    // 返回以node为根的二分搜索树的最小值所在的节点    private Node minimum(Node node){        if(node.left == null)            return node;        return minimum(node.left);    }    // 删除掉以node为根的二分搜索树中的最小节点    // 返回删除节点后新的二分搜索树的根    private Node removeMin(Node node){        if(node.left == null){            Node rightNode = node.right;            node.right = null;            size --;            return rightNode;        }        node.left = removeMin(node.left);        return node;    }    // 从二分搜索树中删除键为key的节点    public V remove(K key){        Node node = getNode(root, key);        if(node != null){            root = remove(root, key);            return node.value;        }        return null;    }    private Node remove(Node node, K key){        if( node == null )            return null;        Node retNode;        if( key.compareTo(node.key) &lt; 0 ){            node.left = remove(node.left , key);            retNode= node;        }        else if(key.compareTo(node.key) &gt; 0 ){            node.right = remove(node.right, key);            retNode= node;        }        else{   // key.compareTo(node.key) == 0            // 待删除节点左子树为空的情况            if(node.left == null){                Node rightNode = node.right;                node.right = null;                size --;                retNode= rightNode;            }else if(node.right == null){ // 待删除节点右子树为空的情况                Node leftNode = node.left;                node.left = null;                size --;                retNode= leftNode;            }else {                // 待删除节点左右子树均不为空的情况                // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点                // 用这个节点顶替待删除节点的位置                Node successor = minimum(node.right);                successor.right = remove(node.right,successor.key);                successor.left = node.left;                node.left = node.right = null;                retNode= successor;            }        }        if(retNode==null)            return retNode;       // 更新height        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));                 int balanceFactor = getBalanceFactor(retNode);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0)            return rightRotate(retNode);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0)            return leftRotate(retNode);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) {            //先进行左旋            node.left= leftRotate(retNode.left);            return rightRotate(retNode);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) {            retNode.right=rightRotate(retNode.right);            return leftRotate(retNode);        }        return retNode;    }    public static void main(String[] args){        System.out.println(&quot;Pride and Prejudice&quot;);        ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) {            System.out.println(&quot;Total words: &quot; + words.size());            AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;();            for (String word : words) {                if (map.contains(word))                    map.set(word, map.get(word) + 1);                else                    map.add(word, 1);            }            System.out.println(&quot;Total different words: &quot; + map.getSize());            System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;));            System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;));            System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST());            System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced());            for(String word:words) {                map.remove(word);                if(!map.isBalanced()||!map.isBST()) {                    throw new RuntimeException(&quot;error！&quot;);                }            }        }        System.out.println();    }    public boolean isBST() {        //BST在中序边遍历是从小到大来的        ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;();        inOrder(root,keys);        for(int i=1;i&lt;keys.size();i++)             //注意i-1            if(keys.get(i-1).compareTo(keys.get(i))&gt;0)                return false;        return true;    }    private void inOrder(Node root, ArrayList&lt;K&gt; keys) {        if(root==null)            return ;        inOrder(root.left, keys);        keys.add(root.key);        inOrder(root.right, keys);    }    //判断二叉树是否是一颗平衡二叉树    public boolean isBalanced() {        return isBalanced(root);    }    //判断以Node为根的二叉树是平衡二叉树，递归算法    public boolean isBalanced(Node node) {        if(node==null)            return true;        int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor)&gt;1)            return false;        return isBalanced(node.left)&amp;&amp;isBalanced(node.right);    }}</code></pre><figure class="third"><br>   <img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><br>    <img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br>   <img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br></figure><p><img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/DFmJgAX.png" width="300" height="200" div="" align="right"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;平衡二叉树的定义&lt;ul&gt;
&lt;li&gt;对于任意一个节点，左子树和右子树的高度差不能超过1&lt;/li&gt;
&lt;li&gt;AVL树
      
    
    </summary>
    
      <category term="dataStuct" scheme="https://jzygaga.github.io/categories/dataStuct/"/>
    
    
      <category term="AVL树" scheme="https://jzygaga.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>lamda</title>
    <link href="https://jzygaga.github.io/2018/12/29/lamda/"/>
    <id>https://jzygaga.github.io/2018/12/29/lamda/</id>
    <published>2018-12-29T09:07:54.000Z</published>
    <updated>2019-01-01T12:33:44.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA8新特性——Lamda表达式"><a href="#JAVA8新特性——Lamda表达式" class="headerlink" title="JAVA8新特性——Lamda表达式"></a>JAVA8新特性——Lamda表达式</h1><h2 id="Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。"><a href="#Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。" class="headerlink" title="Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。"></a>Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。</h2><ul><li><p>先来看看传统的匿名内部类调用方式:</p><pre><code>interface MyInterface{    void lMethod();}public class Main {    public static void test(MyInterface myInterface){        myInterface.lMethod();    }    public static void main(String[] args) {        test(new MyInterface() {            @Override            public void lMethod() {                System.out.println(&quot;Hello World!&quot;);            }        });    }}</code></pre><p>　在主类中的这么几行代码，嵌套几层就为了输出一个Hello World！是不是很麻烦？但是由于java结构的完整性，我们还不得不那么做，现在JDK1.8来了。</p></li><li><p>再来看看使用Lamda表达式改写上面的代码：</p><pre><code> interface Myinterface{    void IMethod(); }public class Main {    public static void test(Myinterface myinterface){        myinterface.IMethod();    }    public static void main(String[] args) {        test(()-&gt; System.out.println(&quot;666&quot;));    }}</code></pre><p>这就是Lamda表达式语言，为了解决匿名内部类繁杂的操作而出现。</p></li><li><p>Lamda语法有三种形式：</p><ol><li>(参数) -&gt;单行语句；</li><li>(参数) -&gt;{多行语句}；</li><li><p>(参数) -&gt;表达式；<br>括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&gt;System.out.println(“Hello World!”) 前面的()代表void lMethod()方法，它没有入参，所以为空，-&gt;后面是一个单行语句；<br>如果-&gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;<br>-&gt;后面也可以是一个表达式，如：a+b等。</p><ul><li><p>(参数) -&gt;单行语句；</p><pre><code> interface MyInterface{    void lMethod(String str);}public class Main {    public static void test(MyInterface myInterface){        myInterface.lMethod(&quot;Hello World!&quot;);//设置参数内容    }    public static void main(String[] args) {        //首先在()中定义此表达式里面需要接收变量s，后面的单行语句中就可以使用该变量了        test((s)-&gt;System.out.println(s));    }}</code></pre></li><li><p>(参数) -&gt;多行语句；</p><pre><code> interface Myinterface{    void IMethod(String str); }public class Main {    public static void test(Myinterface myinterface){        myinterface.IMethod(&quot;hello word&quot;);    }    public static void main(String[] args) {        test((s)-&gt; {            s=s+s;            System.out.println(s);        });    }}</code></pre><p>　这样，Lamda表达式就看起来很简单了，有不有！</p></li></ul></li></ol></li></ul><p>　　匿名内部类，我们比较常用的地方在哪儿？线程类Thread，以前我们可能这样写：</p><h2 id="总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。"><a href="#总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。" class="headerlink" title="总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。"></a>总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA8新特性——Lamda表达式&quot;&gt;&lt;a href=&quot;#JAVA8新特性——Lamda表达式&quot; class=&quot;headerlink&quot; title=&quot;JAVA8新特性——Lamda表达式&quot;&gt;&lt;/a&gt;JAVA8新特性——Lamda表达式&lt;/h1&gt;&lt;h2 id=&quot;L
      
    
    </summary>
    
      <category term="java" scheme="https://jzygaga.github.io/categories/java/"/>
    
    
      <category term="lamda" scheme="https://jzygaga.github.io/tags/lamda/"/>
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="https://jzygaga.github.io/2018/12/20/211.%20Add%20and%20Search%20Word%20-%20Data%20structure%20design/"/>
    <id>https://jzygaga.github.io/2018/12/20/211. Add and Search Word - Data structure design/</id>
    <published>2018-12-20T11:36:27.000Z</published>
    <updated>2019-01-02T06:09:38.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="211-Add-and-Search-Word-Data-structure-design"><a href="#211-Add-and-Search-Word-Data-structure-design" class="headerlink" title="211. Add and Search Word - Data structure design"></a>211. Add and Search Word - Data structure design</h1><p><strong> Design a data structure that supports the following two operations:</strong> </p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><pre><code>addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class WordDictionary {private class Node{    public boolean isWord;    public TreeMap&lt;Character,Node&gt; next;public Node(boolean isWord) {    this.isWord=isWord;    next=new TreeMap&lt;&gt;();}public Node() {    this(false);}}private Node root;private int size;/** Initialize your data structure here. */public WordDictionary() {    root=new Node();    size=0;}/** Adds a word into the data structure. */public void addWord(String word) {    Node cur=root;    for(int i=0;i&lt;word.length();i++) {        char c = word.charAt(i);        if(cur.next.get(c)==null) {            cur.next.put(c, new Node());        }        cur=cur.next.get(c);    }    cur.isWord=true;    size++;}/** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */public boolean search(String word) {    int i=0;    Node cur=root;    return recurtionSearch(i,word,cur);}private boolean recurtionSearch(int i,String str,Node cur) {    if(i==str.length())        return cur.isWord;    char m=str.charAt(i);    if(m!=&apos;.&apos;) {        if(cur.next.get(m)==null)            return false;        return recurtionSearch(++i, str,cur.next.get(m));    }else {        //这个逻辑，就跳过点.这个位置        for(char c:cur.next.keySet())            if(recurtionSearch(++i, str,cur.next.get(c)))                return true;        return false;    }}//    public static void main(String[] args) {//        WordDictionary wordDictionary = new WordDictionary();//        wordDictionary.addWord(&quot;123&quot;);//        ;//        System.out.println(wordDictionary.search(&quot;.3&quot;));//    }}/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;211-Add-and-Search-Word-Data-structure-design&quot;&gt;&lt;a href=&quot;#211-Add-and-Search-Word-Data-structure-design&quot; class=&quot;headerlink&quot; title=&quot;21
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="Trie" scheme="https://jzygaga.github.io/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="https://jzygaga.github.io/2018/12/20/leetcode-208.%20Implement%20Trie%20(Prefix%20Tree)%20-%20%E5%89%AF%E6%9C%AC/"/>
    <id>https://jzygaga.github.io/2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/</id>
    <published>2018-12-20T11:36:27.000Z</published>
    <updated>2019-01-02T05:33:20.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><p><strong> Implement a trie with insert, search, and startsWith methods. </strong> </p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // returns true<br>trie.search(“app”);     // returns false<br>trie.startsWith(“app”); // returns true<br>trie.insert(“app”);<br>trie.search(“app”);     // returns true *</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Trie {private class Node {    public boolean isWord;    public TreeMap&lt;Character, Node&gt; next;    public Node(boolean isWord) {        next = new TreeMap&lt;&gt;();        this.isWord = isWord;    }    public Node() {        this(false);    }}private Node root;private int size;/** Initialize your data structure here. */public Trie() {    root=new Node();    size=0;}/** Inserts a word into the trie. */public void insert(String word) {    Node cur=root;        for(int i=0;i&lt;word.length();i++) {            char c = word.charAt(i);            Node node = cur.next.get(c);            if(node==null)                cur.next.put(c, new Node());            cur=cur.next.get(c);        }        cur.isWord=true;}/** Returns if the word is in the trie. */public boolean search(String word) {    Node cur=root;        for(int i=0;i&lt;word.length();i++) {            char c = word.charAt(i);            if(cur.next.get(c)==null) {                return false;            }            cur=cur.next.get(c);        }    return cur.isWord;}/** * Returns if there is any word in the trie that starts with the given prefix. */public boolean startsWith(String prefix) {    Node cur=root;    for(int i=0;i&lt;prefix.length();i++) {        char c = prefix.charAt(i);        if(cur.next.get(c)==null) {            return false;        }        cur=cur.next.get(c);    }    return true;}//    public static void main(String[] args) {//        String[] arr= {&quot;Trie&quot;,&quot;insert&quot;,&quot;search&quot;,&quot;startWith&quot;,&quot;insert&quot;,&quot;search&quot;};//        Trie trie = new Trie();//        for(int i=0;i&lt;arr.length;i++)//            trie.insert(arr[i]);//        System.out.println(trie.startsWith(&quot;tr&quot;));//        System.out.println(trie.startsWith(&quot;in&quot;));//        System.out.println(trie.startsWith(&quot;sea&quot;));//        System.out.println(trie.search(&quot;Trie&quot;));//        System.out.println(trie.search(&quot;insert&quot;));//        System.out.println(trie.search(&quot;word&quot;));//    }}/*** Your Trie object will be instantiated and called as such:* Trie obj = new Trie();* obj.insert(word);* boolean param_2 = obj.search(word);* boolean param_3 = obj.startsWith(prefix);*/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;208-Implement-Trie-Prefix-Tree&quot;&gt;&lt;a href=&quot;#208-Implement-Trie-Prefix-Tree&quot; class=&quot;headerlink&quot; title=&quot;208. Implement Trie (Prefix Tree
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="Trie" scheme="https://jzygaga.github.io/tags/Trie/"/>
    
  </entry>
  
  <entry>
    <title>递归入门</title>
    <link href="https://jzygaga.github.io/2018/12/16/%E9%80%92%E5%BD%92%E5%85%A5%E9%97%A8/"/>
    <id>https://jzygaga.github.io/2018/12/16/递归入门/</id>
    <published>2018-12-16T09:01:40.000Z</published>
    <updated>2018-12-16T09:01:40.355Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://jzygaga.github.io/2018/12/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://jzygaga.github.io/2018/12/14/多线程/</id>
    <published>2018-12-14T05:53:05.000Z</published>
    <updated>2019-01-01T12:55:43.675Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://i.imgur.com/swmpvzO.jpg" alt="dddddd"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/swmpvzO.jpg&quot; alt=&quot;dddddd&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="多线程" scheme="https://jzygaga.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>capon</title>
    <link href="https://jzygaga.github.io/2018/12/05/capon/"/>
    <id>https://jzygaga.github.io/2018/12/05/capon/</id>
    <published>2018-12-05T06:26:05.000Z</published>
    <updated>2018-12-05T15:28:39.356Z</updated>
    
    <content type="html"><![CDATA[<p>哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
      
    
    </summary>
    
    
      <category term="项目" scheme="https://jzygaga.github.io/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>我滴妈</title>
    <link href="https://jzygaga.github.io/2018/12/05/basic12/"/>
    <id>https://jzygaga.github.io/2018/12/05/basic12/</id>
    <published>2018-12-05T06:01:18.000Z</published>
    <updated>2018-12-08T18:28:23.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>123321是一个非常特殊的数，它从左边读和从右边读是一样的。<br>　　输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>　　输入一行，包含一个正整数n。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>　　按从小到大的顺序输出满足条件的整数，每个整数占一行。</p><p>说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。<br>    package algorithm.Lanqiao.基础练习;</p><pre><code>import java.util.Scanner;public class base9 {public static void main(String[] args) {    int n;    Scanner in = new Scanner(System.in);    n = in.nextInt();    in.close();    //5位的    for (int i = 1; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            for (int k = 0; k &lt; 10; k++) {                if (i * 2 + j * 2 + k == n) {                    System.out.print(i);                    System.out.print(j);                    System.out.print(k);                    System.out.print(j);                    System.out.print(i);                    System.out.println();                }            }        }    }    //6位的    for (int i = 1; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            for (int k = 0; k &lt; 10; k++) {                if (i * 2 + j * 2 + k * 2 == n) {                    System.out.print(i);                    System.out.print(j);                    System.out.print(k);                    System.out.print(k);                    System.out.print(j);                    System.out.print(i);                    System.out.println();                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;123321是一个非常特殊的数，它从左边读和从右边读是一样的。&lt;br&gt;　　输入一个正整数n， 编程求所有这样的五位和六位十进
      
    
    </summary>
    
    
      <category term="蓝桥杯" scheme="https://jzygaga.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>我滴妈</title>
    <link href="https://jzygaga.github.io/2018/12/05/%E8%93%9D%E6%A1%A5%E8%A2%AB%E5%85%A5%E9%97%A8%E9%A2%98%E7%AC%AC%E4%B8%80%E9%A2%98/"/>
    <id>https://jzygaga.github.io/2018/12/05/蓝桥被入门题第一题/</id>
    <published>2018-12-05T06:01:18.000Z</published>
    <updated>2018-12-08T16:08:25.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。</p><p>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入包含一个整数n。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出一行，包含一个整数，表示Fn除以10007的余数。</p><p>说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p><pre><code>package begin4;import java.util.Scanner;public class Main {    public static void main(String[] args) {        int[] f= new int[1000001];        f[1] = f[2] = 1;        for (int i = 3; i &lt;= 1000000; i++) {            f[i] = (f[i-1] + f[i-2]) % 10007;        }        Scanner in = new Scanner(System.in);        System.out.println(f[in.nextInt()]);        in.close();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。&lt;/p&gt;
&lt;p&gt;当n比较大时，Fn也非常大
      
    
    </summary>
    
    
      <category term="蓝桥杯" scheme="https://jzygaga.github.io/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>nihao,exo</title>
    <link href="https://jzygaga.github.io/2018/12/05/nihao-exo/"/>
    <id>https://jzygaga.github.io/2018/12/05/nihao-exo/</id>
    <published>2018-12-05T05:41:29.000Z</published>
    <updated>2018-12-05T05:41:29.959Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://jzygaga.github.io/2018/12/05/hello-world/"/>
    <id>https://jzygaga.github.io/2018/12/05/hello-world/</id>
    <published>2018-12-05T05:01:55.023Z</published>
    <updated>2018-12-05T05:01:55.023Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
