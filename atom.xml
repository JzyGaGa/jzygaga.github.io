<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>飞翔的傻瓜</title>
  
  <subtitle>菜鸟的试飞之旅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jzygaga.github.io/"/>
  <updated>2019-01-08T06:37:00.643Z</updated>
  <id>https://jzygaga.github.io/</id>
  
  <author>
    <name>FlyingFool</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python入门</title>
    <link href="https://jzygaga.github.io/2019/01/07/python-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://jzygaga.github.io/2019/01/07/python-的数据类型/</id>
    <published>2019-01-07T13:50:37.000Z</published>
    <updated>2019-01-08T06:37:00.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h2><h3 id="python的数据类型"><a href="#python的数据类型" class="headerlink" title="python的数据类型"></a>python的数据类型</h3><p>type(1<em>1)<br>class ‘int’<br>type(1</em>1.0)<br>class ‘float’<br>type(2/2)<br>class ‘float’<br>type(2//2)<br>class ‘int’<br><strong>双斜杠是除完然后取整。</strong></p><h3 id="python的进制"><a href="#python的进制" class="headerlink" title="python的进制"></a>python的进制</h3><ul><li>0b表示二进制<br>0b11-&gt;3<br>0b10-&gt;2</li><li>0o表示8进制<br>0o10-&gt;8<br>0o11-&gt;9</li><li>0x表示16进制<br>0x10-&gt;16<br>0x11-&gt;17</li><li>bin（）方法完成其他进制转换成二进制</li><li>int（）方法将其他进制转换成十进制</li><li>hex（）方法将其他进制转换成16进制</li><li>oct（）方法将其他进制转换成8进制</li></ul><h3 id="python的bool的类型"><a href="#python的bool的类型" class="headerlink" title="python的bool的类型"></a>python的bool的类型</h3><ul><li>bool(1） true</li><li>bool(2)  true</li><li>bool(3)  true</li><li>bool(0)  false</li></ul><h3 id="python中为什么有单双引号"><a href="#python中为什么有单双引号" class="headerlink" title="python中为什么有单双引号"></a>python中为什么有单双引号</h3><ol><li>“let us go”</li><li>‘let us go’</li><li>“let’s go”</li><li>“let’s go”</li><li>“let\’s go”</li><li>“let’s go”</li></ol><ul><li>单双引号换行<ul><li>‘hello\world’,</li><li>“””hello world “””</li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li>“hello world”[0:-2]<br>‘hello wor’</li><li>“hello world”[1]<br>‘e’</li><li>“hello world”[2]<br>‘l’</li><li>“hello world”[3]<br>‘l’</li><li>“hello world”[4]<br>‘o’</li><li>r’dfdfdf’或者R’dfdfdffd’原始字符串<h3 id="python中的列表"><a href="#python中的列表" class="headerlink" title="python中的列表"></a>python中的列表</h3></li></ol><ul><li>list里面可以存放任意类型<br>1.输出：[1, 2, 3, ‘1’, True, False]<br> 结果：[1,2,3,’1’,True,False]</li><li>list里面读取字符</li></ul><ol><li>[“第一技能”,”第二季能”,”第三季能”,”第四技能”][1:3]<br> [‘第二季能’, ‘第三季能’]</li></ol><ul><li>list添加元素<br>[“第一技能”,”第二季能”,”第三季能”,”第四技能”]+[“点燃”,”虚弱”]</li></ul><h3 id="python中的元组"><a href="#python中的元组" class="headerlink" title="python中的元组"></a>python中的元组</h3><p>-表示形式</p><ol><li>>&gt;&gt; (1,2,3,4,5)<pre><code>(1, 2, 3, 4, 5)</code></pre></li><li>>&gt;&gt; type((1,2,3,4,5))<pre><code>&lt;class &apos;tuple&apos;&gt;</code></pre></li></ol><ul><li>对于只含有一个元素的元组</li></ul><ol><li>>&gt;&gt; type((1))<pre><code>&lt;class &apos;int&apos;&gt;</code></pre></li><li>>&gt;&gt; type((‘1’))<pre><code>&lt;class &apos;str&apos;&gt;</code></pre></li><li>>&gt;&gt; type((‘False’))<pre><code>&lt;class &apos;str&apos;&gt;</code></pre></li><li>>&gt;&gt; type((False))<pre><code>&lt;class &apos;bool&apos;&gt;</code></pre><strong>对于一个元素的元组，python会把他当成一个数学运算。</strong></li></ol><p><strong>元组，序列，列表都称之为序列</strong></p><h3 id="python中的序列"><a href="#python中的序列" class="headerlink" title="python中的序列"></a>python中的序列</h3><ol><li>判断是否有元素在里面<br>>&gt;&gt; 3 in [1,2,3,4,5,6]<br>True<br>>&gt;&gt; 3 not in [1,2,3,4,5,6]<br>False</li><li>对元组进行判断<ol><li>>&gt;&gt; len([1,3,5,4,6,8])<br>6</li><li>>&gt;&gt; max([1,3,5,4,6,8])<br>8</li><li>>&gt;&gt; min([1,3,5,4,6,8])<br>1</li><li>>&gt;&gt; min(‘helloword’)<br>‘d’</li><li>>&gt;&gt; max(‘helloword’)<br>‘w’</li></ol></li><li>用ord（’’）读取ascall值<ol><li>>&gt;&gt; ord(‘ ‘)<br>32</li><li>>&gt;&gt; ord(‘w’)<br>119</li><li>>&gt;&gt; ord(‘r’)<br>114</li></ol></li></ol><h3 id="python中的集合"><a href="#python中的集合" class="headerlink" title="python中的集合"></a>python中的集合</h3><ul><li>集合是无序的，所以他没有序列的</li><li><p>集合具有不重复性</p></li><li><p>>&gt;&gt; {1,2,3,4,4,5,6}<br>  {1, 2, 3, 4, 5, 6}</p></li><li>>&gt;&gt; len({1,2,3,4,5})<br>5</li><li>>&gt;&gt; 1 in {1,2,3,4}<br>True</li><li>>&gt;&gt; 1 not in {1,2,3,4}<br>False</li><li>>&gt;&gt; {1,2,3,4,5,6}-{1,2}<br>{3, 4, 5, 6}</li><li>>&gt;&gt; {1,2,3,4,5,6}&amp;{3,4}<br>{3, 4}</li><li>>&gt;&gt; {1,2,3,4,5,6}|{3,4,7}<br>{1, 2, 3, 4, 5, 6, 7}</li><li>>&gt;&gt; type({})<br>class ‘dict’</li><li>>&gt;&gt; type(set())<br>class ‘set’</li><li>>&gt;&gt; len(set())<br>0</li></ul><h3 id="python中的字典"><a href="#python中的字典" class="headerlink" title="python中的字典"></a>python中的字典</h3><ul><li>字典 key-value</li></ul><ol><li>>&gt;&gt; {‘Q’:’新月打击’,’W’:’苍白值瀑’,’E’:’月之降临’,’R’:’月神冲刺’}[‘Q’]<br>‘新月打击’</li></ol><ul><li>value可以是任意类型，key是只能唯一的基本类型。<br><img src="https://i.imgur.com/B1nzF66.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一行代码&quot;&gt;&lt;a href=&quot;#第一行代码&quot; class=&quot;headerlink&quot; title=&quot;第一行代码&quot;&gt;&lt;/a&gt;第一行代码&lt;/h2&gt;&lt;h3 id=&quot;python的数据类型&quot;&gt;&lt;a href=&quot;#python的数据类型&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>快速过桥</title>
    <link href="https://jzygaga.github.io/2019/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%BF%AB%E9%80%9F%E8%BF%87%E6%A1%A5/"/>
    <id>https://jzygaga.github.io/2019/01/07/蓝桥杯-快速过桥/</id>
    <published>2019-01-07T03:41:51.000Z</published>
    <updated>2019-01-07T04:55:10.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速过桥"><a href="#快速过桥" class="headerlink" title="快速过桥"></a>快速过桥</h2><ul><li><strong>问题描述：</strong>n个人的队伍想在晚上通过一座大桥。任何时间最多有2人通过，每组必须有一个手电筒。很可怜，这n个人只有一个手电筒可用，因此必须合理地安排，让手电筒能回到另一端，这样才能让更多人通过大桥。每个人有不同的速度，编组后，一个组的速度等于慢的那个人的速度。你的任务是实现一种策略，让所有人在最短时间内通过。</li><li><strong>样例输入</strong><br>【样例输入】<br>  1<br>  4<br>  1<br>  2<br>  5<br>  10<br>【样例输出】<br>  17<br>  1 2<br>  1<br>  5 10<br>  2<br>  1 2</li><li><a href="https://blog.csdn.net/qq_41061455/article/details/79536991" target="_blank" rel="noopener">https://blog.csdn.net/qq_41061455/article/details/79536991</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速过桥&quot;&gt;&lt;a href=&quot;#快速过桥&quot; class=&quot;headerlink&quot; title=&quot;快速过桥&quot;&gt;&lt;/a&gt;快速过桥&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;n个人的队伍想在晚上通过一座大桥。任何时间最多有2人通过，每组必须有
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://jzygaga.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="智力题" scheme="https://jzygaga.github.io/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://jzygaga.github.io/2019/01/06/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://jzygaga.github.io/2019/01/06/剑指offer-斐波那契数列/</id>
    <published>2019-01-06T06:34:09.000Z</published>
    <updated>2019-01-06T09:37:25.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><ul><li>描述<br><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 </strong></li><li>代码<pre><code>public int Fibonacci1(int n) {      if(n==1)          return 1;      if(n==2)          return 1;        int[] arr=new int[n];        arr[0]=1;        arr[1]=1;        for(int i=2;i&lt;n;i++) {            arr[i]=arr[i-1]+arr[i-2];        }        return arr[n-1];    }</code></pre></li><li><p>代码</p><pre><code>import java.util.HashMap;import java.util.Map;public class Solution {    private Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();    public int Fibonacci(int n) {         if(n==1)           return 1;         if(n==2)          return 1;         if(map.get(n)!=null)             return map.get(n);        map.put(n, Fibonacci(n-1)+Fibonacci(n-2));        return map.get(n);    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;描述&lt;br&gt;&lt;strong&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Powerful Integers</title>
    <link href="https://jzygaga.github.io/2019/01/06/leetcode-970.%20Powerful%20Integers/"/>
    <id>https://jzygaga.github.io/2019/01/06/leetcode-970. Powerful Integers/</id>
    <published>2019-01-06T05:57:10.000Z</published>
    <updated>2019-01-06T06:09:29.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="970-Powerful-Integers"><a href="#970-Powerful-Integers" class="headerlink" title="970. Powerful Integers"></a>970. Powerful Integers</h2><ul><li><strong>描述：</strong>Given two non-negative integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &gt;= 0 and j &gt;= 0.</li><li>例子<ul><li>例子1<br>   Input: x = 2, y = 3, bound = 10<pre><code>Output: [2,3,4,5,7,9,10]Explanation: 2 = 2^0 + 3^03 = 2^1 + 3^04 = 2^0 + 3^15 = 2^1 + 3^17 = 2^2 + 3^19 = 2^3 + 3^010 = 2^0 + 3^2</code></pre></li></ul></li><li><p>代码</p><ul><li><p>while</p><pre><code>class Solution {      public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) {         int maxV=Math.max(x, y);         int minV=Math.min(x, y);         int sum;         int sumMaxV=1;         int sumMinV=1;        Set&lt;Integer&gt; set=new HashSet&lt;&gt;();        //3         while(sumMaxV&lt;=bound) {             sumMinV=1;             while(sumMinV&lt;=(bound-sumMaxV)) {                 sum=sumMaxV+sumMinV;                // if(sum&gt;bound)                //     break;     while()条件已经判断了                 set.add(sum);               if(minV==1)                     break;                 sumMinV*=minV;             }             sumMaxV*=maxV;              if(maxV==1)                     break;         }         return new ArrayList&lt;&gt;(set);     }}</code></pre></li><li><p>for</p><pre><code>    public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) {        Set&lt;Integer&gt; result = new HashSet&lt;&gt;();        for (int a = 1; a &lt; bound; a *= x) {            for (int b = 1; a + b &lt;= bound; b *= y) {                result.add(a + b);                if (y == 1) {                    break;                }            }            if (x == 1) {                break;            }        }        return new ArrayList&lt;&gt;(result);    }}</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;970-Powerful-Integers&quot;&gt;&lt;a href=&quot;#970-Powerful-Integers&quot; class=&quot;headerlink&quot; title=&quot;970. Powerful Integers&quot;&gt;&lt;/a&gt;970. Powerful Integers
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>图结构</title>
    <link href="https://jzygaga.github.io/2019/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>https://jzygaga.github.io/2019/01/05/数据结构-图/</id>
    <published>2019-01-05T03:01:15.000Z</published>
    <updated>2019-01-05T13:36:37.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><ul><li>图的分类<ul><li>有向图，无向图<ul><li>边上有方向</li><li>边上无方向</li></ul></li><li>有权图，无权图<ul><li>有权图，边上有值。</li><li>无权图，边上无值。</li></ul></li></ul></li><li>图的连通性<ul><li>判断图之间是否连通</li><li>连通分量</li></ul></li><li>边<ul><li>自环边</li><li>平行边<br><img src="https://i.imgur.com/MoWEPbr.png" alt=""></li></ul></li></ul><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><ul><li><p>邻接矩阵<br><img src="https://i.imgur.com/TcAYKKm.png" alt=""></p><pre><code>package graphic;    /**     * 密集矩阵用邻接矩阵     * @author 59842     *     */    public class DenseGraph {        //有多少个定点        private int n;        //有多少个边        private int m;        //是否有向//true表示有向图        private boolean directed;        //存储图的有向结构        private boolean[][] g;        public DenseGraph(int n, boolean directed) {            this.n=n;            this.m=0;            this.directed=directed;            g=new boolean [n][n];        }        public void addEdge(int v,int w) {            if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n)                throw new IllegalArgumentException(&quot;边超出了范围&quot;);            if(hasEdge(v,w))                return ;            g[v][w]=true;            if(!directed)                //不是有向图                g[w][v]=true;            m++;        }        private boolean hasEdge(int v, int w) {            if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n)                throw new IllegalArgumentException(&quot;边超出了范围&quot;);            return g[w][v]=false;        }        public int getV() {            return n;        }        public int getE() {            return m;        }    }</code></pre></li><li><p>邻接表<br><img src="https://i.imgur.com/IOng9e6.png" alt=""></p></li><li><p>完全图</p><ul><li>适用的场景，每个电影的相似程度。有权图<br><strong>邻接表适合表示稀疏图，邻接矩阵适合表示稠密图</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图结构&quot;&gt;&lt;a href=&quot;#图结构&quot; class=&quot;headerlink&quot; title=&quot;图结构&quot;&gt;&lt;/a&gt;图结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;图的分类&lt;ul&gt;
&lt;li&gt;有向图，无向图&lt;ul&gt;
&lt;li&gt;边上有方向&lt;/li&gt;
&lt;li&gt;边上无方向&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="图结构" scheme="https://jzygaga.github.io/categories/%E5%9B%BE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://jzygaga.github.io/2019/01/04/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://jzygaga.github.io/2019/01/04/剑指offer-用两个栈实现队列/</id>
    <published>2019-01-04T03:08:18.000Z</published>
    <updated>2019-01-04T03:13:44.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong></p><ul><li><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><ul><li><p>自己解</p><pre><code>import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();     public void push(int node) {           stack1.push(node);    }    public int pop() {        while(!stack1.isEmpty()) {            stack2.push(stack1.pop());        }        Integer toPop = stack2.pop();        while(!stack2.isEmpty()) {            stack1.push(stack2.pop());        }        return toPop;    }}</code></pre></li><li><p>渐优解</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自己解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Stac
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://jzygaga.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://jzygaga.github.io/2019/01/04/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://jzygaga.github.io/2019/01/04/剑指offer-重建二叉树/</id>
    <published>2019-01-04T02:47:53.000Z</published>
    <updated>2019-01-04T02:52:54.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>题目描述</strong></p><ul><li><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><pre><code>/** * Definition for binary tree * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {     public TreeNode reConstructBinaryTree(int [] pre,int [] in) {        if(pre==null||in==null||pre.length!=in.length)            return null;       return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);    }    private TreeNode reConstructBinaryTree(int[] pre,int pStart,int pEnd,int[] in,int iStart,int iEnd){        //一般性问题        if(pStart&gt;pEnd)            return null;        //创建根节点        TreeNode root=new TreeNode(pre[pStart]);        //找到中序遍历中的位置        int loc;        for(loc=0;loc&lt;in.length;loc++){            if(in[loc]==pre[pStart]){                break;            }        }        //计算左右子树节点的个数。        int len=loc-iStart;        root.left=reConstructBinaryTree(pre,pStart+1,pStart+len,in,iStart,iStart+len-1);        root.right=reConstructBinaryTree(pre,pStart+len+1,pEnd,in,iStart+len+1,iEnd);        return root;    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重建二叉树&quot;&gt;&lt;a href=&quot;#重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;重建二叉树&quot;&gt;&lt;/a&gt;重建二叉树&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://jzygaga.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>234. Palindrome Linked List</title>
    <link href="https://jzygaga.github.io/2019/01/03/leetcode-%E5%8D%95%E9%93%BE%E8%A1%A8-234.%20Palindrome%20Linked%20List/"/>
    <id>https://jzygaga.github.io/2019/01/03/leetcode-单链表-234. Palindrome Linked List/</id>
    <published>2019-01-03T06:32:36.000Z</published>
    <updated>2019-01-03T06:38:51.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a>Palindrome Linked List</h2><ul><li>描述：<strong>Given a singly linked list, determine if it is a palindrome.</strong></li><li>例子：<ul><li>Input: 1-&gt;2 ，Output: false </li><li>Input: 1-&gt;2-&gt;2-&gt;1，Output: true</li></ul></li></ul><p><strong>代码1</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Palindrome-Linked-List&quot;&gt;&lt;a href=&quot;#Palindrome-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Palindrome Linked List&quot;&gt;&lt;/a&gt;Palindrome Linked Li
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="单链表" scheme="https://jzygaga.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>206. Reverse Linked List</title>
    <link href="https://jzygaga.github.io/2019/01/03/leetcode-206.%20Reverse%20Linked%20List/"/>
    <id>https://jzygaga.github.io/2019/01/03/leetcode-206. Reverse Linked List/</id>
    <published>2019-01-03T04:18:55.000Z</published>
    <updated>2019-01-03T05:51:01.841Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h2><p><strong>Reverse a singly linked list.</strong><br><strong> Example:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>代码</strong></p><ul><li><p>迭代的代码</p><pre><code>class Solution {     public ListNode reverseList(ListNode head) {        ListNode reverseNode=null;        ListNode cur=head;        ListNode toDeal=null;        while(cur!=null) {            //拿到待处理的节点            toDeal =cur;            cur=cur.next;            //拿到一边进行连接            toDeal.next=reverseNode;            reverseNode=toDeal;        }        return reverseNode;    }}</code></pre></li></ul><ul><li><p>递归的代码<br><strong>代码一</strong></p><pre><code>class Solution {     public ListNode reverseList(ListNode head) {        if(head==null||head.next==null)            return head;        return toReverse(head,null);    }    private ListNode toReverse(ListNode head, ListNode reverse) {        if(head==null) {            return reverse;        }        ListNode cur=head.next;        //与另一个链表相连接        head.next=reverse;        //        reverse=head;        return toReverse(cur,reverse);    }}</code></pre></li></ul><p><strong>代码二</strong></p><pre><code>public ListNode reverseList(ListNode head) {    if(head==null||head.next==null)        return head;    ListNode newHead= reverseList(head.next);    //两个借点之间的链接进行翻转    head.next.next=head;    head.next=null;    return newHead;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reverse-Linked-List&quot;&gt;&lt;a href=&quot;#Reverse-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Reverse Linked List&quot;&gt;&lt;/a&gt;Reverse Linked List&lt;/h2&gt;&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="链表" scheme="https://jzygaga.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Middle of the Linked List</title>
    <link href="https://jzygaga.github.io/2019/01/03/leetcode-876.%20Middle%20of%20the%20Linked%20List/"/>
    <id>https://jzygaga.github.io/2019/01/03/leetcode-876. Middle of the Linked List/</id>
    <published>2019-01-02T22:05:24.000Z</published>
    <updated>2019-01-02T22:54:08.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876. Middle of the Linked List"></a>876. Middle of the Linked List</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><strong> Given a non-empty, singly linked list with head node head, return a middle node of linked list.<br>if there are two middle nodes, return the second middle node. </strong></p><ul><li>Example 1:<br>  Input: [1,2,3,4,5]<br>  Output: Node 3 from this list (Serialization: [3,4,5])<br>  The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>  Note that we returned a ListNode object ans, such that:<br>  ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</li><li><p>Example 2：<br>  Input: [1,2,3,4,5]<br>  Output: Node 3 from this list (Serialization: [3,4,5])<br>  The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>  Note that we returned a ListNode object ans, such that:<br>  ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</p><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><pre><code>    class Solution {    public ListNode middleNode(ListNode head) {        ListNode node=head;        int i=0;        while(node!=null) {             i++;             node=node.next;        }        int loc=i/2+1;        i=1;        ListNode node1=head;        while(i&lt;loc) {            node1=node1.next;            i++;        }        return node1;    }}</code></pre><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><pre><code>public ListNode middleNode(ListNode head) {    ListNode listNode = new ListNode(0);    ListNode fast=head;    ListNode low=head;    while(fast!=null&amp;&amp;fast.next!=null) {        fast=fast.next.next;        low=low.next;    }    return low.next;}</code></pre><h3 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a>代码三</h3><pre><code>  class Solution {    public ListNode middleNode(ListNode head) {        ListNode fast=head;        ListNode low=head;        //对比2方法，假装自己先跑了两步         if(fast!=null&amp;&amp;fast.next!=null){            fast=fast.next.next;        }else{            return low;        }        while(fast!=null&amp;&amp;fast.next!=null) {            fast=fast.next.next;            low=low.next;        }        return low.next;    }}</code></pre><h3 id="代码四"><a href="#代码四" class="headerlink" title="代码四"></a>代码四</h3><pre><code>public ListNode middleNode(ListNode head) {    ListNode fast=head;    ListNode low=head;    //对比2方法，假装自己先跑了两步    if(head==null&amp;&amp;head.next==null)        return head;    while(fast!=null&amp;&amp;fast.next!=null) {        fast=fast.next.next;        low=low.next;    }    return low;}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;876-Middle-of-the-Linked-List&quot;&gt;&lt;a href=&quot;#876-Middle-of-the-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;876. Middle of the Linked List&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="链表" scheme="https://jzygaga.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://jzygaga.github.io/2019/01/02/%E5%89%91%E6%8C%87offer-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%20/"/>
    <id>https://jzygaga.github.io/2019/01/02/剑指offer-二维数组中的查找 /</id>
    <published>2019-01-02T06:19:14.000Z</published>
    <updated>2019-01-03T08:21:57.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>描述：</strong></p><ul><li><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>代码</strong></p><pre><code>public class Solution {    public boolean Find(int target, int [][] array) {        int y=0;        int x=array.length-1;        int row=array.length-1;        int col=array[0].length-1;        while((0&lt;=x&amp;&amp;x&lt;=col)&amp;&amp;(0&lt;=y&amp;&amp;y&lt;=row)){            if(array[x][y]==target)                return true;            if(array[x][y]&lt;target){                y++;               continue;             }            if(array[x][y]&gt;target){                x--;               continue;            }        }        return false;    }}</code></pre><h2 id="注意数组根据先后赋值，排列是从上到下来的"><a href="#注意数组根据先后赋值，排列是从上到下来的" class="headerlink" title="注意数组根据先后赋值，排列是从上到下来的"></a>注意数组根据先后赋值，排列是从上到下来的</h2></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二维数组中的查找&quot;&gt;&lt;a href=&quot;#二维数组中的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组中的查找&quot;&gt;&lt;/a&gt;二维数组中的查找&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在一个二维数组中（
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://jzygaga.github.io/2019/01/02/java-%E5%8F%8D%E5%B0%84/"/>
    <id>https://jzygaga.github.io/2019/01/02/java-反射/</id>
    <published>2019-01-02T05:34:53.000Z</published>
    <updated>2019-01-02T06:16:14.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对方的付费"><a href="#对方的付费" class="headerlink" title="对方的付费"></a>对方的付费</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对方的付费&quot;&gt;&lt;a href=&quot;#对方的付费&quot; class=&quot;headerlink&quot; title=&quot;对方的付费&quot;&gt;&lt;/a&gt;对方的付费&lt;/h2&gt;
      
    
    </summary>
    
      <category term="java" scheme="https://jzygaga.github.io/categories/java/"/>
    
    
      <category term="反射" scheme="https://jzygaga.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>AVL树</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL%E6%A0%91/"/>
    <id>https://jzygaga.github.io/2019/01/01/数据结构-AVL树/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T07:53:15.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li>平衡二叉树的定义<ul><li>对于任意一个节点，左子树和右子树的高度差不能超过1</li><li>AVL树有着自己的平衡性，所以在自己的增加和删除，不会退化成一个链表</li></ul></li><li>满二叉树<br>   <img src="https://i.imgur.com/vpxDXic.png" width="100" height="100" div="" align="right"><ul><li>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空</li></ul></li><li>AVL<ul><li>定义每一个节点的高度</li><li>计算平衡因子 <ul><li>定义： 每个节点的平衡因子等于左子树减去右子树的差</li><li>作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的<br><img src="https://i.imgur.com/gutLgG7.png" width="200" height="200" div="" align="right"></li></ul></li><li>AVL的左旋转右旋转<ul><li>当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。<br>*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。</li></ul></li></ul></li></ul><pre><code>package AVLTree;import java.util.ArrayList;public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; {    private class Node{        public K key;        public V value;        public Node left, right;        public int height;        public Node(K key, V value){            this.key = key;            this.value = value;            left = null;            right = null;            height = 1;        }    }    private Node root;    private int size;    public AVLTree(){        root = null;        size = 0;    }    public int getSize(){        return size;    }    public boolean isEmpty(){        return size == 0;    }    // 获得节点node的高度    private int getHeight(Node node){        if(node == null)            return 0;        return node.height;    }    // 获得节点node的平衡因子    private int getBalanceFactor(Node node){        if(node == null)            return 0;        return getHeight(node.left) - getHeight(node.right);    }    // 向二分搜索树中添加新的元素(key, value)    public void add(K key, V value){        root = add(root, key, value);    }    // 向以node为根的二分搜索树中插入元素(key, value)，递归算法    // 返回插入新节点后二分搜索树的根    private Node add(Node node, K key, V value){        if(node == null){            size ++;            return new Node(key, value);        }        if(key.compareTo(node.key) &lt; 0)            node.left = add(node.left, key, value);        else if(key.compareTo(node.key) &gt; 0)            node.right = add(node.right, key, value);        else // key.compareTo(node.key) == 0            node.value = value;        // 更新height        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));                 int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0)            return rightRotate(node);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0)            return leftRotate(node);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) {            //先进行左旋            node.left= leftRotate(node.left);            return rightRotate(node);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) {            node.right=rightRotate(node.right);            return leftRotate(node);        }        return node;    }    //对节点进行左旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          T1  x   向右旋转(y),左侧过高不平衡                   y    z    //             / \    ----------------------&gt;               / \   / \    //          T2  z                                     T1 T2 T3 T4    //             / \   //                T4  T3    //    private Node leftRotate(Node y) {        Node x=y.right;        Node T2=x.right;        //向右旋转过程        x.left=y;        y.right=T2;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    //对节点进行右旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          x   T4    向右旋转(y),左侧过高不平衡                   z    y    //         / \      ----------------------&gt;               / \   / \    //      z   T3                                        T1 T2 T3 T4    //     / \    //      T1  T2    // 返回以node为根节点的二分搜索树中，key所在的节点    private Node rightRotate(Node y) {        Node x=y.left;        Node T3=x.right;        //向右旋转过程        x.right=y;        y.left=T3;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    private Node getNode(Node node, K key){        if(node == null)            return null;        if(key.equals(node.key))            return node;        else if(key.compareTo(node.key) &lt; 0)            return getNode(node.left, key);        else // if(key.compareTo(node.key) &gt; 0)            return getNode(node.right, key);    }    public boolean contains(K key){        return getNode(root, key) != null;    }    public V get(K key){        Node node = getNode(root, key);        return node == null ? null : node.value;    }    public void set(K key, V newValue){        Node node = getNode(root, key);        if(node == null)            throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;);        node.value = newValue;    }    // 返回以node为根的二分搜索树的最小值所在的节点    private Node minimum(Node node){        if(node.left == null)            return node;        return minimum(node.left);    }    // 删除掉以node为根的二分搜索树中的最小节点    // 返回删除节点后新的二分搜索树的根    private Node removeMin(Node node){        if(node.left == null){            Node rightNode = node.right;            node.right = null;            size --;            return rightNode;        }        node.left = removeMin(node.left);        return node;    }    // 从二分搜索树中删除键为key的节点    public V remove(K key){        Node node = getNode(root, key);        if(node != null){            root = remove(root, key);            return node.value;        }        return null;    }    private Node remove(Node node, K key){        if( node == null )            return null;        Node retNode;        if( key.compareTo(node.key) &lt; 0 ){            node.left = remove(node.left , key);            retNode= node;        }        else if(key.compareTo(node.key) &gt; 0 ){            node.right = remove(node.right, key);            retNode= node;        }        else{   // key.compareTo(node.key) == 0            // 待删除节点左子树为空的情况            if(node.left == null){                Node rightNode = node.right;                node.right = null;                size --;                retNode= rightNode;            }else if(node.right == null){ // 待删除节点右子树为空的情况                Node leftNode = node.left;                node.left = null;                size --;                retNode= leftNode;            }else {                // 待删除节点左右子树均不为空的情况                // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点                // 用这个节点顶替待删除节点的位置                Node successor = minimum(node.right);                successor.right = remove(node.right,successor.key);                successor.left = node.left;                node.left = node.right = null;                retNode= successor;            }        }        if(retNode==null)            return retNode;       // 更新height        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));                 int balanceFactor = getBalanceFactor(retNode);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0)            return rightRotate(retNode);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0)            return leftRotate(retNode);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) {            //先进行左旋            node.left= leftRotate(retNode.left);            return rightRotate(retNode);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) {            retNode.right=rightRotate(retNode.right);            return leftRotate(retNode);        }        return retNode;    }    public static void main(String[] args){        System.out.println(&quot;Pride and Prejudice&quot;);        ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) {            System.out.println(&quot;Total words: &quot; + words.size());            AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;();            for (String word : words) {                if (map.contains(word))                    map.set(word, map.get(word) + 1);                else                    map.add(word, 1);            }            System.out.println(&quot;Total different words: &quot; + map.getSize());            System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;));            System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;));            System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST());            System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced());            for(String word:words) {                map.remove(word);                if(!map.isBalanced()||!map.isBST()) {                    throw new RuntimeException(&quot;error！&quot;);                }            }        }        System.out.println();    }    public boolean isBST() {        //BST在中序边遍历是从小到大来的        ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;();        inOrder(root,keys);        for(int i=1;i&lt;keys.size();i++)             //注意i-1            if(keys.get(i-1).compareTo(keys.get(i))&gt;0)                return false;        return true;    }    private void inOrder(Node root, ArrayList&lt;K&gt; keys) {        if(root==null)            return ;        inOrder(root.left, keys);        keys.add(root.key);        inOrder(root.right, keys);    }    //判断二叉树是否是一颗平衡二叉树    public boolean isBalanced() {        return isBalanced(root);    }    //判断以Node为根的二叉树是平衡二叉树，递归算法    public boolean isBalanced(Node node) {        if(node==null)            return true;        int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor)&gt;1)            return false;        return isBalanced(node.left)&amp;&amp;isBalanced(node.right);    }}</code></pre><figure class="third"><br>   <img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><br>    <img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br>   <img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br></figure><p><img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/DFmJgAX.png" width="300" height="200" div="" align="right"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AVL树&quot;&gt;&lt;a href=&quot;#AVL树&quot; class=&quot;headerlink&quot; title=&quot;AVL树&quot;&gt;&lt;/a&gt;AVL树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;平衡二叉树的定义&lt;ul&gt;
&lt;li&gt;对于任意一个节点，左子树和右子树的高度差不能超过1&lt;/li&gt;
&lt;li&gt;AVL树
      
    
    </summary>
    
      <category term="数据结构" scheme="https://jzygaga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="AVL树" scheme="https://jzygaga.github.io/tags/AVL%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>https://jzygaga.github.io/2019/01/01/数据结构-红黑树/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T07:48:33.848Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ul><li><p>红黑树定义</p><ul><li>算法导论的定义</li></ul></li><li><p>满二叉树</p><ul><li>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空</li></ul></li><li>AVL<ul><li>定义每一个节点的高度</li><li>计算平衡因子 <ul><li>定义： 每个节点的平衡因子等于左子树减去右子树的差</li><li>作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的<br><img src="https://i.imgur.com/gutLgG7.png" width="200" height="200" div="" align="right"></li></ul></li><li>AVL的左旋转右旋转<ul><li>当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。<br>*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。</li></ul></li></ul></li></ul><pre><code>package AVLTree;import java.util.ArrayList;public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; {    private class Node{        public K key;        public V value;        public Node left, right;        public int height;        public Node(K key, V value){            this.key = key;            this.value = value;            left = null;            right = null;            height = 1;        }    }    private Node root;    private int size;    public AVLTree(){        root = null;        size = 0;    }    public int getSize(){        return size;    }    public boolean isEmpty(){        return size == 0;    }    // 获得节点node的高度    private int getHeight(Node node){        if(node == null)            return 0;        return node.height;    }    // 获得节点node的平衡因子    private int getBalanceFactor(Node node){        if(node == null)            return 0;        return getHeight(node.left) - getHeight(node.right);    }    // 向二分搜索树中添加新的元素(key, value)    public void add(K key, V value){        root = add(root, key, value);    }    // 向以node为根的二分搜索树中插入元素(key, value)，递归算法    // 返回插入新节点后二分搜索树的根    private Node add(Node node, K key, V value){        if(node == null){            size ++;            return new Node(key, value);        }        if(key.compareTo(node.key) &lt; 0)            node.left = add(node.left, key, value);        else if(key.compareTo(node.key) &gt; 0)            node.right = add(node.right, key, value);        else // key.compareTo(node.key) == 0            node.value = value;        // 更新height        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));                 int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0)            return rightRotate(node);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0)            return leftRotate(node);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) {            //先进行左旋            node.left= leftRotate(node.left);            return rightRotate(node);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) {            node.right=rightRotate(node.right);            return leftRotate(node);        }        return node;    }    //对节点进行左旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          T1  x   向右旋转(y),左侧过高不平衡                   y    z    //             / \    ----------------------&gt;               / \   / \    //          T2  z                                     T1 T2 T3 T4    //             / \   //                T4  T3    //    private Node leftRotate(Node y) {        Node x=y.right;        Node T2=x.right;        //向右旋转过程        x.left=y;        y.right=T2;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    //对节点进行右旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          x   T4    向右旋转(y),左侧过高不平衡                   z    y    //         / \      ----------------------&gt;               / \   / \    //      z   T3                                        T1 T2 T3 T4    //     / \    //      T1  T2    // 返回以node为根节点的二分搜索树中，key所在的节点    private Node rightRotate(Node y) {        Node x=y.left;        Node T3=x.right;        //向右旋转过程        x.right=y;        y.left=T3;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    private Node getNode(Node node, K key){        if(node == null)            return null;        if(key.equals(node.key))            return node;        else if(key.compareTo(node.key) &lt; 0)            return getNode(node.left, key);        else // if(key.compareTo(node.key) &gt; 0)            return getNode(node.right, key);    }    public boolean contains(K key){        return getNode(root, key) != null;    }    public V get(K key){        Node node = getNode(root, key);        return node == null ? null : node.value;    }    public void set(K key, V newValue){        Node node = getNode(root, key);        if(node == null)            throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;);        node.value = newValue;    }    // 返回以node为根的二分搜索树的最小值所在的节点    private Node minimum(Node node){        if(node.left == null)            return node;        return minimum(node.left);    }    // 删除掉以node为根的二分搜索树中的最小节点    // 返回删除节点后新的二分搜索树的根    private Node removeMin(Node node){        if(node.left == null){            Node rightNode = node.right;            node.right = null;            size --;            return rightNode;        }        node.left = removeMin(node.left);        return node;    }    // 从二分搜索树中删除键为key的节点    public V remove(K key){        Node node = getNode(root, key);        if(node != null){            root = remove(root, key);            return node.value;        }        return null;    }    private Node remove(Node node, K key){        if( node == null )            return null;        Node retNode;        if( key.compareTo(node.key) &lt; 0 ){            node.left = remove(node.left , key);            retNode= node;        }        else if(key.compareTo(node.key) &gt; 0 ){            node.right = remove(node.right, key);            retNode= node;        }        else{   // key.compareTo(node.key) == 0            // 待删除节点左子树为空的情况            if(node.left == null){                Node rightNode = node.right;                node.right = null;                size --;                retNode= rightNode;            }else if(node.right == null){ // 待删除节点右子树为空的情况                Node leftNode = node.left;                node.left = null;                size --;                retNode= leftNode;            }else {                // 待删除节点左右子树均不为空的情况                // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点                // 用这个节点顶替待删除节点的位置                Node successor = minimum(node.right);                successor.right = remove(node.right,successor.key);                successor.left = node.left;                node.left = node.right = null;                retNode= successor;            }        }        if(retNode==null)            return retNode;       // 更新height        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));                 int balanceFactor = getBalanceFactor(retNode);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0)            return rightRotate(retNode);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0)            return leftRotate(retNode);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) {            //先进行左旋            node.left= leftRotate(retNode.left);            return rightRotate(retNode);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) {            retNode.right=rightRotate(retNode.right);            return leftRotate(retNode);        }        return retNode;    }    public static void main(String[] args){        System.out.println(&quot;Pride and Prejudice&quot;);        ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) {            System.out.println(&quot;Total words: &quot; + words.size());            AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;();            for (String word : words) {                if (map.contains(word))                    map.set(word, map.get(word) + 1);                else                    map.add(word, 1);            }            System.out.println(&quot;Total different words: &quot; + map.getSize());            System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;));            System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;));            System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST());            System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced());            for(String word:words) {                map.remove(word);                if(!map.isBalanced()||!map.isBST()) {                    throw new RuntimeException(&quot;error！&quot;);                }            }        }        System.out.println();    }    public boolean isBST() {        //BST在中序边遍历是从小到大来的        ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;();        inOrder(root,keys);        for(int i=1;i&lt;keys.size();i++)             //注意i-1            if(keys.get(i-1).compareTo(keys.get(i))&gt;0)                return false;        return true;    }    private void inOrder(Node root, ArrayList&lt;K&gt; keys) {        if(root==null)            return ;        inOrder(root.left, keys);        keys.add(root.key);        inOrder(root.right, keys);    }    //判断二叉树是否是一颗平衡二叉树    public boolean isBalanced() {        return isBalanced(root);    }    //判断以Node为根的二叉树是平衡二叉树，递归算法    public boolean isBalanced(Node node) {        if(node==null)            return true;        int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor)&gt;1)            return false;        return isBalanced(node.left)&amp;&amp;isBalanced(node.right);    }}</code></pre><figure class="third"><br>   <img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><br>    <img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br>   <img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br></figure><p><img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/DFmJgAX.png" width="300" height="200" div="" align="right"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;红黑树&quot;&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; title=&quot;红黑树&quot;&gt;&lt;/a&gt;红黑树&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;红黑树定义&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法导论的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;满二叉树&lt;/
      
    
    </summary>
    
      <category term="数据结构" scheme="https://jzygaga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="红黑树" scheme="https://jzygaga.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jzygaga.github.io/2019/01/01/设计模式-代理模式/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T05:15:53.836Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="https://jzygaga.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="代理模式" scheme="https://jzygaga.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E4%BA%A7%E6%A8%A1%E5%BC%8F/"/>
    <id>https://jzygaga.github.io/2019/01/01/设计模式-工产模式/</id>
    <published>2019-01-01T12:53:48.000Z</published>
    <updated>2019-01-02T05:10:24.762Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="设计模式" scheme="https://jzygaga.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="工厂模式" scheme="https://jzygaga.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="https://jzygaga.github.io/2019/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>https://jzygaga.github.io/2019/01/01/计算机网络/</id>
    <published>2019-01-01T09:27:13.000Z</published>
    <updated>2019-01-02T06:24:02.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络的分层"><a href="#计算机网络的分层" class="headerlink" title="计算机网络的分层"></a>计算机网络的分层</h2><ul><li>应用层：数据服务那个协议。</li><li>传输层：解决出错重传机制，</li><li>网络层：</li><li>数据链路层：</li><li>物理层：不可靠，不安全。<br><strong><br>发展时代：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层，<br>  不可靠，不安全。对数据的检验，数据服务那个协议，出错重传，应用协议。</strong><h2 id="网络传输的不可靠"><a href="#网络传输的不可靠" class="headerlink" title="网络传输的不可靠"></a>网络传输的不可靠</h2></li><li>丢包，重复包</li><li>出错</li><li>乱序<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2></li><li>问题提出<br><img src="https://i.imgur.com/lxcwUo2.png" alt=""></li><li>改进方案<br><img src="https://i.imgur.com/myI3wuL.png" alt=""></li><li>功能<ul><li>增加吞吐量，提高效率。</li></ul></li></ul><p><img src="https://i.imgur.com/ldNfkuL.png" alt=""></p><p><img src="https://i.imgur.com/oIyB5gf.png" alt=""><br><strong>一直等5的ack接受信号，整个接受5ack信号，接受到5返回整个接受ack信息。比如，未接受到5的ack信息，即使接收到6，7，8，9，10，11也不会发送ack信息</strong><br><img src="https://i.imgur.com/Ev0hBwa.png" alt=""></p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p><img src="https://i.imgur.com/IjZ2S3X.png" alt=""></p><ul><li>Src：IntelCor电脑 Dst:到路由器  链路层</li><li>Src:本机的ip地址 Dst:DNS服务器</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机网络的分层&quot;&gt;&lt;a href=&quot;#计算机网络的分层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络的分层&quot;&gt;&lt;/a&gt;计算机网络的分层&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;应用层：数据服务那个协议。&lt;/li&gt;
&lt;li&gt;传输层：解决出错重传机制，&lt;/li
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://jzygaga.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://jzygaga.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="https://jzygaga.github.io/2018/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>https://jzygaga.github.io/2018/12/30/数据结构-哈希表/</id>
    <published>2018-12-30T06:57:43.000Z</published>
    <updated>2019-01-02T07:48:35.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h2><h3 id="例子：387-First-Unique-Character-in-a-String"><a href="#例子：387-First-Unique-Character-in-a-String" class="headerlink" title="例子：387. First Unique Character in a String"></a>例子：387. First Unique Character in a String</h3><p><strong><br>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</strong></p><pre><code>Examples:s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2.</code></pre><p><strong>代码</strong></p><pre><code>class Solution {public int firstUniqChar(String s) {    int[] arr=new int[26];    for(int i=0;i&lt;s.length();i++){        arr[s.charAt(i)-&apos;a&apos;]++;    }    for(int i=0;i&lt;s.length();i++){        if(arr[s.charAt(i)-&apos;a&apos;]==1)            return i;    }    return -1;}}</code></pre><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><ul><li>对于我们所关注的内容，比如例子中的字符串，我们建立字符串与我们想要得到值之间的索引的数据结构，我们称之为哈希表。</li><li>对于转换的过程我们称之为哈希函数。f(ch)=ch-‘a’;<ul><li>哈希函数就是把’键’转换成’索引’，如果不同的健对应相同值称之为哈希冲突。</li></ul></li><li>学习哈希表主要解决的问题：<ul><li>把键转换成索引</li><li>解决哈希冲突</li></ul></li><li>哈希表充分体现了算法设计思想：空间换时间。</li><li>通过健得到索引分越均匀越好。</li></ul><h2 id="哈希函数的设计"><a href="#哈希函数的设计" class="headerlink" title="哈希函数的设计"></a>哈希函数的设计</h2><ul><li>对于整型<ul><li>小范围的正整数正常使用</li><li>小范围的负整数进行偏移 -100~100-0~200</li><li>大整数 比如身份证号码<br><code>110108198512166666</code> 选择模一个素数。</li></ul></li><li>浮点型转换成整型<br>  <img src="https://i.imgur.com/yEOX2mI.png" alt=""></li><li>字符串 转成整型处理<ul><li>166 1<em>100+6</em>10+6*1</li><li>code c<em>26^3+o</em>26^2+d<em>26^1+e</em>26^0;</li><li>hash(code)=(c<em>B^3+o</em>B^2+d<em>B^1+e</em>B^0)%M;<br><img src="https://i.imgur.com/8fAdQtg.png" alt=""></li></ul></li><li>设计哈希函数的原则：<ul><li>一致性：如果a==b,则hash(a)==hash(b)</li><li>高效性：计算高校便捷</li><li>均匀性：哈希值均匀分布</li></ul></li></ul><h2 id="java中的hashcode"><a href="#java中的hashcode" class="headerlink" title="java中的hashcode"></a>java中的hashcode</h2><pre><code>package Hashtable;public class Student {    private int grade;    private int cls;    private String firstName;    private String lastName;    public Student(int grade, int cls, String firstName, String lastName) {        this.grade = grade;        this.cls = cls;        this.firstName = firstName;        this.lastName = lastName;    }    @Override    public int hashCode() {        int B=31;        int hash=0;        hash=hash*B+grade;        hash=hash*B+cls;        //不区分大小写。。        hash=hash*B+firstName.hashCode();        hash=hash*B+lastName.hashCode();        return hash;    }}</code></pre><h2 id="java中解决hashcode的方法-Seperate-Chaining"><a href="#java中解决hashcode的方法-Seperate-Chaining" class="headerlink" title="java中解决hashcode的方法 Seperate    Chaining"></a>java中解决hashcode的方法 Seperate    Chaining</h2><ul><li>(hashCode(k1)&amp;0x7fffffff)%M 根据hash值就算出索引</li><li><p>如果产生冲突了，就在后面添加一个，就相当于每个索引后面接一个链表，但是我们为了优化访问的速度，可以接一个红黑树。<br><img src="https://i.imgur.com/WKkYGA6.png" alt=""></p><ul><li>k2-&gt;k3相当于一个查找表。所以hashMap就相当于treemap的数组，HashSet相当于treeSet数组。</li></ul></li><li><p><strong>在java8之前每一个位置对应一个链表，java8之后一开始一个位置对应一个链表，当哈希冲突达到一定程度每一个位置从链表变成红黑树，在数量小的时候红黑树会进行反转等操作。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;哈希表&quot;&gt;&lt;a href=&quot;#哈希表&quot; class=&quot;headerlink&quot; title=&quot;哈希表&quot;&gt;&lt;/a&gt;哈希表&lt;/h1&gt;&lt;h2 id=&quot;导学&quot;&gt;&lt;a href=&quot;#导学&quot; class=&quot;headerlink&quot; title=&quot;导学&quot;&gt;&lt;/a&gt;导学&lt;/h2&gt;&lt;h
      
    
    </summary>
    
      <category term="数据结构" scheme="https://jzygaga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="哈希表" scheme="https://jzygaga.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>lamda</title>
    <link href="https://jzygaga.github.io/2018/12/29/java-lamda/"/>
    <id>https://jzygaga.github.io/2018/12/29/java-lamda/</id>
    <published>2018-12-29T09:07:54.000Z</published>
    <updated>2019-01-01T12:33:44.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA8新特性——Lamda表达式"><a href="#JAVA8新特性——Lamda表达式" class="headerlink" title="JAVA8新特性——Lamda表达式"></a>JAVA8新特性——Lamda表达式</h1><h2 id="Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。"><a href="#Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。" class="headerlink" title="Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。"></a>Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。</h2><ul><li><p>先来看看传统的匿名内部类调用方式:</p><pre><code>interface MyInterface{    void lMethod();}public class Main {    public static void test(MyInterface myInterface){        myInterface.lMethod();    }    public static void main(String[] args) {        test(new MyInterface() {            @Override            public void lMethod() {                System.out.println(&quot;Hello World!&quot;);            }        });    }}</code></pre><p>　在主类中的这么几行代码，嵌套几层就为了输出一个Hello World！是不是很麻烦？但是由于java结构的完整性，我们还不得不那么做，现在JDK1.8来了。</p></li><li><p>再来看看使用Lamda表达式改写上面的代码：</p><pre><code> interface Myinterface{    void IMethod(); }public class Main {    public static void test(Myinterface myinterface){        myinterface.IMethod();    }    public static void main(String[] args) {        test(()-&gt; System.out.println(&quot;666&quot;));    }}</code></pre><p>这就是Lamda表达式语言，为了解决匿名内部类繁杂的操作而出现。</p></li><li><p>Lamda语法有三种形式：</p><ol><li>(参数) -&gt;单行语句；</li><li>(参数) -&gt;{多行语句}；</li><li><p>(参数) -&gt;表达式；<br>括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&gt;System.out.println(“Hello World!”) 前面的()代表void lMethod()方法，它没有入参，所以为空，-&gt;后面是一个单行语句；<br>如果-&gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;<br>-&gt;后面也可以是一个表达式，如：a+b等。</p><ul><li><p>(参数) -&gt;单行语句；</p><pre><code> interface MyInterface{    void lMethod(String str);}public class Main {    public static void test(MyInterface myInterface){        myInterface.lMethod(&quot;Hello World!&quot;);//设置参数内容    }    public static void main(String[] args) {        //首先在()中定义此表达式里面需要接收变量s，后面的单行语句中就可以使用该变量了        test((s)-&gt;System.out.println(s));    }}</code></pre></li><li><p>(参数) -&gt;多行语句；</p><pre><code> interface Myinterface{    void IMethod(String str); }public class Main {    public static void test(Myinterface myinterface){        myinterface.IMethod(&quot;hello word&quot;);    }    public static void main(String[] args) {        test((s)-&gt; {            s=s+s;            System.out.println(s);        });    }}</code></pre><p>　这样，Lamda表达式就看起来很简单了，有不有！</p></li></ul></li></ol></li></ul><p>　　匿名内部类，我们比较常用的地方在哪儿？线程类Thread，以前我们可能这样写：</p><h2 id="总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。"><a href="#总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。" class="headerlink" title="总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。"></a>总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA8新特性——Lamda表达式&quot;&gt;&lt;a href=&quot;#JAVA8新特性——Lamda表达式&quot; class=&quot;headerlink&quot; title=&quot;JAVA8新特性——Lamda表达式&quot;&gt;&lt;/a&gt;JAVA8新特性——Lamda表达式&lt;/h1&gt;&lt;h2 id=&quot;L
      
    
    </summary>
    
      <category term="java" scheme="https://jzygaga.github.io/categories/java/"/>
    
    
      <category term="lamda" scheme="https://jzygaga.github.io/tags/lamda/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="https://jzygaga.github.io/2018/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>https://jzygaga.github.io/2018/12/22/数据结构-并查集/</id>
    <published>2018-12-22T03:44:56.000Z</published>
    <updated>2019-01-02T07:44:40.976Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="数据结构" scheme="https://jzygaga.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="并查集" scheme="https://jzygaga.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
</feed>
