<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>指尖上的手艺人</title>
  
  <subtitle>菜鸟的试飞之旅</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jzygaga.github.io/"/>
  <updated>2019-02-18T14:13:27.813Z</updated>
  <id>https://jzygaga.github.io/</id>
  
  <author>
    <name>Rocky</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>旋转最小的数字</title>
    <link href="https://jzygaga.github.io/2019/02/18/%E5%87%86%E5%A4%87%E7%BC%96%E8%BE%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>https://jzygaga.github.io/2019/02/18/准备编辑的博客/</id>
    <published>2019-02-18T14:07:52.000Z</published>
    <updated>2019-02-18T14:13:27.813Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong>代码：</strong></p><pre><code>    import java.util.ArrayList;public class Solution {    public int minNumberInRotateArray(int [] array) {        if(array==null||array.length==0){            return 0;        }        int index1 = 0;        int index2 = array.length - 1;        int indexmid = index1;        while (array[index1] &gt;= array[index2]) {            if ((index2 -index1) == 1)                return array[index2];            /**             * 会存在....{10111111}             * 无法判断中间的一个1是属于第一个递增的空间还是第二个递增空间             */            indexmid=(index1+index2)/2;            if(array[indexmid]==array[index1]&amp;&amp;array[index1]==array[index2])                return MinInOrder(array,index1,index2);            if(array[index1]&lt;=array[indexmid])                index1=indexmid;            else if(array[index2]&gt;=array[indexmid])                index2=indexmid;        }        //直接排好序了就return。        return array[index2];    }    private int MinInOrder(int[] array, int index1, int index2) {        int res=array[index1];        for (int i = index1+1; i &lt; index2; i++) {            if(res&gt;array[i]){                res=array[i];            }        }        return res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>旋转最小的数字</title>
    <link href="https://jzygaga.github.io/2019/02/18/%E5%89%91%E6%8C%87offer-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>https://jzygaga.github.io/2019/02/18/剑指offer-旋转数组中最小的数字/</id>
    <published>2019-02-18T14:07:52.000Z</published>
    <updated>2019-02-18T14:12:29.546Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p><strong>代码：</strong></p><pre><code>    import java.util.ArrayList;public class Solution {    public int minNumberInRotateArray(int [] array) {        if(array==null||array.length==0){            return 0;        }        int index1 = 0;        int index2 = array.length - 1;        int indexmid = index1;        while (array[index1] &gt;= array[index2]) {            if ((index2 -index1) == 1)                return array[index2];            /**             * 会存在....{10111111}             * 无法判断中间的一个1是属于第一个递增的空间还是第二个递增空间             */            indexmid=(index1+index2)/2;            if(array[indexmid]==array[index1]&amp;&amp;array[index1]==array[index2])                return MinInOrder(array,index1,index2);            if(array[index1]&lt;=array[indexmid])                index1=indexmid;            else if(array[index2]&gt;=array[indexmid])                index2=indexmid;        }        //直接排好序了就return。        return array[index2];    }    private int MinInOrder(int[] array, int index1, int index2) {        int res=array[index1];        for (int i = index1+1; i &lt; index2; i++) {            if(res&gt;array[i]){                res=array[i];            }        }        return res;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>准备编辑的博客</title>
    <link href="https://jzygaga.github.io/2019/02/16/%E5%87%86%E5%A4%87%E7%BC%96%E8%BE%91%E7%9A%84%E5%8D%9A%E5%AE%A2-2/"/>
    <id>https://jzygaga.github.io/2019/02/16/准备编辑的博客-2/</id>
    <published>2019-02-16T15:49:49.000Z</published>
    <updated>2019-02-16T15:49:50.047Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>青蛙跳台阶</title>
    <link href="https://jzygaga.github.io/2019/01/24/%E5%89%91%E6%8C%87offer-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
    <id>https://jzygaga.github.io/2019/01/24/剑指offer-青蛙跳台阶/</id>
    <published>2019-01-24T13:50:58.000Z</published>
    <updated>2019-02-16T15:56:18.119Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><strong>代码：</strong><br>这样又占了几个空间</p><pre><code>    public class Solution {     public int JumpFloor(int target) {        if(target==1)            return 1;        if(target==2)            return 2;        int[] arr=new int[target];        arr[0]=1;        arr[1]=2;        for(int i=0;i&lt;target;i++){            arr[i]=arr[i-1]+arr[i-2];        }        return arr[target-1];    }}</code></pre><p><strong>代码：</strong></p><pre><code>public int JumpFloor(int target) {    if(target&lt;0)        return 0;    if(target==1||target==2)        return target;    int j1=1,j2=2,res=0;    for(int i=2;i&lt;target;i++){        res=j1+j2;        j1=j2;        j2=res;    }    return res;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。&lt;br&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;br&gt;这样又占了几个空间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>准备编辑的博客</title>
    <link href="https://jzygaga.github.io/2019/01/17/%E5%87%86%E5%A4%87%E7%BC%96%E8%BE%91%E7%9A%84%E5%8D%9A%E5%AE%A2-1/"/>
    <id>https://jzygaga.github.io/2019/01/17/准备编辑的博客-1/</id>
    <published>2019-01-17T13:21:25.000Z</published>
    <updated>2019-01-17T13:21:25.263Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AQS同步组件-Semaphore</title>
    <link href="https://jzygaga.github.io/2019/01/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-AQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6-Semaphore/"/>
    <id>https://jzygaga.github.io/2019/01/17/java并发编程-AQS同步组件-Semaphore/</id>
    <published>2019-01-17T13:05:03.000Z</published>
    <updated>2019-01-17T13:24:25.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Semaphore？"><a href="#1-Semaphore？" class="headerlink" title="1.Semaphore？"></a>1.Semaphore？</h2><p>　技术信号量用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数据。计数信号量可以用来实现资源池或者给一个容器限定边界。</p><p>　　信号量维护了一个许可集，许可的初始量通过构造函数传递给Semaphore。活动能够获取许可，并在使用之后释放许可，如果没有可用的许可，acquire方法会被阻塞，直到有可用的为止。每个release方法添加一个许可，从而可能释放一个正在阻塞的获取者</p><h2 id="2-使用方法"><a href="#2-使用方法" class="headerlink" title="2.使用方法"></a>2.使用方法</h2><ul><li>Semaphore(int permits，boolean fair) 设置公平还是不公平的。</li><li>Semaphore(int permits)：创建具有给定许可数和非公平设置的Semaphore</li><li>int availablePermits() ：返回此信号量中当前可用的许可证数。</li><li>int getQueueLength()：返回正在等待获取许可证的线程数。</li><li>boolean hasQueuedThreads() ：是否有线程正在等待获取许可证。</li><li>void reducePermits(int reduction) ：减少reduction个许可证。是个protected方法。</li><li>Collection getQueuedThreads() ：返回所有等待获取许可证的线程集合。是个protected方法。</li></ul><h2 id="3-SemaphoreDemo"><a href="#3-SemaphoreDemo" class="headerlink" title="3.SemaphoreDemo"></a>3.SemaphoreDemo</h2><ul><li><p>SemaphoreDemo</p><pre><code>package com.mmall.concurrency.example.AQS.semaphore;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Semaphore;public class SemaphoreDemo {    public static void main(String[] args) {        Semaphore semaphore=new Semaphore(3);        Workers worker=new Workers(&quot;小黄&quot;,semaphore);        Workers worker1=new Workers(&quot;小蓝&quot;,semaphore);        Workers worker2=new Workers(&quot;小白&quot;,semaphore);        Workers worker3=new Workers(&quot;小子&quot;,semaphore);        Workers worker4=new Workers(&quot;小绿&quot;,semaphore);        Workers worker5=new Workers(&quot;小黑&quot;,semaphore);        Workers worker6=new Workers(&quot;小红&quot;,semaphore);        ExecutorService executorService=Executors.newCachedThreadPool();        executorService.execute(worker);        executorService.execute(worker1);        executorService.execute(worker2);        executorService.execute(worker3);        executorService.execute(worker4);        executorService.execute(worker5);        executorService.execute(worker6);    }}</code></pre></li><li><p>Workers</p><pre><code>package com.mmall.concurrency.example.AQS.semaphore;import lombok.extern.slf4j.Slf4j;import java.util.concurrent.Semaphore;@Slf4jpublic class Workers implements Runnable {    private String name;    private Semaphore semaphore;    public Workers(String name, Semaphore semaphore) {        this.name = name;        this.semaphore = semaphore;    }    @Override    public void run() {        try {            semaphore.acquire();            System.out.println(String.format(&quot;%s拿到了指令许可&quot;, name));            Thread.sleep(3000);            System.out.println(String.format(&quot;%s工作结束，还剩%s没有拿到指令许可&quot;, name, semaphore.getQueueLength()));        }catch (Exception e){            log.info(&quot;error{}&quot;,e);        }        semaphore.release();    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Semaphore？&quot;&gt;&lt;a href=&quot;#1-Semaphore？&quot; class=&quot;headerlink&quot; title=&quot;1.Semaphore？&quot;&gt;&lt;/a&gt;1.Semaphore？&lt;/h2&gt;&lt;p&gt;　技术信号量用来控制能够同时访问某特定资源的活动的数量，或者
      
    
    </summary>
    
      <category term="java并发" scheme="https://jzygaga.github.io/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="https://jzygaga.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>AQS同步组件-CountDownLatch</title>
    <link href="https://jzygaga.github.io/2019/01/17/java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-AQS%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6-CountDownLatch/"/>
    <id>https://jzygaga.github.io/2019/01/17/java并发编程-AQS同步组件-CountDownLatch/</id>
    <published>2019-01-17T11:40:17.000Z</published>
    <updated>2019-01-17T12:13:13.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-什么是CountDownLatch？"><a href="#1-什么是CountDownLatch？" class="headerlink" title="1.什么是CountDownLatch？"></a>1.什么是CountDownLatch？</h2><p>CountDownLatch是闭锁，CountDownLatch是JAVA提供在java.util.concurrent包下的一个辅助类，可以把它看成是一个计数器，其内部维护着一个count计数，只不过对这个计数器的操作都是<strong>原子操作</strong>，同时只能有一个线程去操作这个计数器，CountDownLatch通过构造函数传入一个初始计数值，调用者可以通过调用CounDownLatch对象的cutDown()方法，来使计数减1；如果调用对象上的await()方法，那么调用者就会一直阻塞在这里，直到别人通过cutDown方法，将计数减到0，才可以继续执行。</p><ul><li><strong>原子操作</strong> :所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切 [1]  换到另一个线程）。<h2 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2.应用场景"></a>2.应用场景</h2></li></ul><ol><li>确保一个计算不会执行，直到它所需要的资源被初始化</li><li>确保一个服务不会开始，直到它依赖的其他服务都已经开始</li><li>等待，直到活动的所有部分都为继续处理做好充分准备</li></ol><h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3.使用方法"></a>3.使用方法</h2><ul><li>void await()：使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</li><li>void await()：使当前线程在锁存器倒计数至零之前一直等待，除非线程被中断。</li><li>void countDown()：递减锁存器的计数，如果计数到达零，则释放所有等待的线程。</li><li>long getCount()：返回当前计数。</li><li>String toString()：返回标识此锁存器及其状态的字符串。</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><ul><li><p>Boss类</p><pre><code>package com.mmall.concurrency.example.AQS.countDownDemo;import lombok.extern.slf4j.Slf4j;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;@Slf4jpublic class Boss implements Runnable{    private CountDownLatch countDownLatch;    private String name;    public Boss(CountDownLatch countDownLatch,String name){        this.countDownLatch=countDownLatch;        this.name=name;    }    @Override    public void run() {        System.out.println(String.format(&quot;%s开始检查了&quot;,name));        try {        TimeUnit.SECONDS.sleep(new Random().nextInt(10));        }catch (Exception e){            log.error(&quot;{}&quot;,e);        }        try {            countDownLatch.await();        }catch (Exception e){            log.error(&quot;{}&quot;,e);        }        System.out.println(String.format(&quot;%s检查完了&quot;,name));    }}</code></pre></li><li><p>work类</p><pre><code>package com.mmall.concurrency.example.AQS.countDownDemo;import lombok.extern.slf4j.Slf4j;import java.util.Random;import java.util.concurrent.CountDownLatch;import java.util.concurrent.TimeUnit;@Slf4jpublic class Worker implements Runnable{    private CountDownLatch countDownLatch;    private String name;    public Worker(CountDownLatch countDownLatch,String name){        this.countDownLatch=countDownLatch;        this.name=name;    }    @Override    public void run() {        System.out.println(String.format(&quot;%s开始干活了&quot;,name));        try {            TimeUnit.SECONDS.sleep(new Random().nextInt(10));        }catch (Exception e){            log.error(&quot;{}&quot;,e);        }        System.out.println(String.format(&quot;%s干完活了&quot;,name));        countDownLatch.countDown();        log.info(&quot;{}&quot;,countDownLatch.getCount());    }}</code></pre></li><li><p>CountDownLatchDemo</p><pre><code>package com.mmall.concurrency.example.AQS.countDownDemo;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class CountDownLatchDemo {    public static void main(String[] args) {        ExecutorService executorService=Executors.newCachedThreadPool();        CountDownLatch countDownLatch=new CountDownLatch(3);        Worker worker1=new Worker(countDownLatch,&quot;小明&quot;);        Worker worker2=new Worker(countDownLatch,&quot;老王&quot;);        Worker worker3=new Worker(countDownLatch,&quot;张三&quot;);        Boss boss=new Boss(countDownLatch,&quot;王老板&quot;);        executorService.execute(worker1);        executorService.execute(worker2);        executorService.execute(worker3);        executorService.execute(boss);        executorService.shutdown();    }}</code></pre></li><li><p>res</p><pre><code>王老板开始检查了小明开始干活了老王开始干活了张三开始干活了张三干完活了20:11:25.822 [pool-1-thread-3] INFO com.mmall.concurrency.example.AQS.countDownDemo.Worker - 2老王干完活了20:11:28.818 [pool-1-thread-2] INFO com.mmall.concurrency.example.AQS.countDownDemo.Worker - 1小明干完活了王老板检查完了20:11:31.818 [pool-1-thread-1] INFO com.mmall.concurrency.example.AQS.countDownDemo.Worker - 0</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-什么是CountDownLatch？&quot;&gt;&lt;a href=&quot;#1-什么是CountDownLatch？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是CountDownLatch？&quot;&gt;&lt;/a&gt;1.什么是CountDownLatch？&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="java并发" scheme="https://jzygaga.github.io/categories/java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="java并发" scheme="https://jzygaga.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Non-decreasing Array</title>
    <link href="https://jzygaga.github.io/2019/01/13/leetocde-665.%20Non-decreasing%20Array/"/>
    <id>https://jzygaga.github.io/2019/01/13/leetocde-665. Non-decreasing Array/</id>
    <published>2019-01-13T09:06:29.000Z</published>
    <updated>2019-01-13T09:16:05.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="665-Non-decreasing-Array"><a href="#665-Non-decreasing-Array" class="headerlink" title="665. Non-decreasing Array"></a>665. Non-decreasing Array</h2><ul><li><strong>问题描述：</strong><br>Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element.<br>We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). </li><li><p><strong>Example 1:</strong><br>Input: [4,2,3]<br>Output: True<br>Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</p><pre><code>class Solution {    public boolean checkPossibility(int[] nums) {            int modifyCount = 0;            for(int i = 1; i &lt; nums.length; i++) {                if(nums[i - 1] &gt; nums[i]) {                    modifyCount++;                    if(modifyCount&gt;1)                        return false;                    if(i - 2 &gt;= 0 &amp;&amp; nums[i - 2] &gt; nums[i]) {                        nums[i] = nums[i - 1];                    } else {                        nums[i - 1] = nums[i];                    }                }            }            return true;        }    }</code></pre><p><a href="http://www.cnblogs.com/grandyang/p/7565424.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/7565424.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;665-Non-decreasing-Array&quot;&gt;&lt;a href=&quot;#665-Non-decreasing-Array&quot; class=&quot;headerlink&quot; title=&quot;665. Non-decreasing Array&quot;&gt;&lt;/a&gt;665. Non-decr
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Redis之（一）初识Redis</title>
    <link href="https://jzygaga.github.io/2019/01/12/Redis%E4%B9%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%88%9D%E8%AF%86Redis/"/>
    <id>https://jzygaga.github.io/2019/01/12/Redis之（一）初识Redis/</id>
    <published>2019-01-12T07:56:21.000Z</published>
    <updated>2019-01-13T05:50:17.500Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、Redis概述"><a href="#1、Redis概述" class="headerlink" title="1、Redis概述"></a>1、Redis概述</h2><p>我们知道，内存是电脑主板上的存储部件，用于存储当前正在使用的数据和程序，CPU可以与内存直接沟通，所以访问速速非常高；而外存数据必须加载到内存以后程序才能使用。如果把CPU当做一个吃货，那么内存是碗，而外存是锅，这个吃货再能吃，也得先把饭从锅里盛到碗里再下嘴，而不能直接跳到锅里大快朵颐。但是很多时候CPU吃的并不爽，一是因为碗不够大，没吃两嘴就没了；二是从锅里往碗里盛饭是个比较耗时的过程，等待很痛苦。正经点说，就是内存大小、I/O速度、网络响应时间等常常成为应用系统的性能瓶颈。</p><p>传统的关系型数据库如MySQL、Oracle、DB2等，数据存储在磁盘的文件系统中，增删改查需要频繁地在内存与外存之间交换数据，很费时间。试想，如果有一种小巧而功能强大的存储结构，<strong>用于在内存中管理数据量不太大但是访问量特别大的热点数据</strong>。<br>在以上背景下，Redis应运而生。</p><p>Redis是Remote Dictionary Server的简称，是一个由意大利人Salvatore Sanfilippo开发的key-value存储系统，具有极高的读写性能，读的速度可达110000次/s，写的速度可达81000次/s 。</p><p>与Redis类似的产品还有memcache，同样是一个基于内存的key-value存储系统，但是由于memcache数据结构单一，数据安全性低下等原因，大有被Redis取而代之的趋势。</p><p>Redis 与其他 key - value 缓存产品相比，有以下特点：</p><ol><li><p>Redis支持数据的持久化，周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，重启的时候可以再次加载进行使用。</p></li><li><p>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</p></li><li><p>Redis支持数据的备份，即master-slave模式的数据备份。</p></li><li><p>Redis的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。</p></li><li><p>Redis还支持 publish/subscribe, 通知, key过期等高级特性。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、Redis概述&quot;&gt;&lt;a href=&quot;#1、Redis概述&quot; class=&quot;headerlink&quot; title=&quot;1、Redis概述&quot;&gt;&lt;/a&gt;1、Redis概述&lt;/h2&gt;&lt;p&gt;我们知道，内存是电脑主板上的存储部件，用于存储当前正在使用的数据和程序，CPU可以与
      
    
    </summary>
    
      <category term="Redis" scheme="https://jzygaga.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="https://jzygaga.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>准备编辑的博客</title>
    <link href="https://jzygaga.github.io/2019/01/09/java-Json/"/>
    <id>https://jzygaga.github.io/2019/01/09/java-Json/</id>
    <published>2019-01-09T08:42:03.000Z</published>
    <updated>2019-01-09T13:55:22.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="JSON简介绍"><a href="#JSON简介绍" class="headerlink" title="JSON简介绍"></a>JSON简介绍</h3><ul><li>JSON 英语的全写 JavaScript Object Notation<br>javaScript 对象标记</li><li>JSON是一个轻量级的数据格式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JSON&quot;&gt;&lt;a href=&quot;#JSON&quot; class=&quot;headerlink&quot; title=&quot;JSON&quot;&gt;&lt;/a&gt;JSON&lt;/h2&gt;&lt;h3 id=&quot;JSON简介绍&quot;&gt;&lt;a href=&quot;#JSON简介绍&quot; class=&quot;headerlink&quot; title=&quot;JSO
      
    
    </summary>
    
      <category term="java" scheme="https://jzygaga.github.io/categories/java/"/>
    
    
      <category term="JSON" scheme="https://jzygaga.github.io/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>python的正则表达式</title>
    <link href="https://jzygaga.github.io/2019/01/09/python-3%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Cjson/"/>
    <id>https://jzygaga.github.io/2019/01/09/python-3的正则表达式和json/</id>
    <published>2019-01-09T07:47:46.000Z</published>
    <updated>2019-01-09T07:59:14.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre><code>import relanguage = &apos;PythonC#JavaC#PHPC#&apos;def convert(value):    match = value.group()    return &apos;!!&apos;+match+&apos;!!&apos;r = re.sub(&apos;C#&apos;, convert, language)print(r)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式&quot;&gt;&lt;a href=&quot;#正则表达式&quot; class=&quot;headerlink&quot; title=&quot;正则表达式&quot;&gt;&lt;/a&gt;正则表达式&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;import re

language = &amp;apos;PythonC#JavaC#PHPC#&amp;ap
      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python的赋值</title>
    <link href="https://jzygaga.github.io/2019/01/08/python-2%E8%B5%8B%E5%80%BC/"/>
    <id>https://jzygaga.github.io/2019/01/08/python-2赋值/</id>
    <published>2019-01-08T06:47:52.000Z</published>
    <updated>2019-01-08T07:05:15.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python的赋值"><a href="#python的赋值" class="headerlink" title="python的赋值"></a>python的赋值</h3><ul><li>int str tuple （不可改变）的值类型</li><li>list set dict（可改变） 的引用类型</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python的赋值&quot;&gt;&lt;a href=&quot;#python的赋值&quot; class=&quot;headerlink&quot; title=&quot;python的赋值&quot;&gt;&lt;/a&gt;python的赋值&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;int str tuple （不可改变）的值类型&lt;/li&gt;
&lt;li&gt;li
      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python入门</title>
    <link href="https://jzygaga.github.io/2019/01/07/python-1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://jzygaga.github.io/2019/01/07/python-1数据类型/</id>
    <published>2019-01-07T13:50:37.000Z</published>
    <updated>2019-01-08T06:37:00.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一行代码"><a href="#第一行代码" class="headerlink" title="第一行代码"></a>第一行代码</h2><h3 id="python的数据类型"><a href="#python的数据类型" class="headerlink" title="python的数据类型"></a>python的数据类型</h3><p>type(1<em>1)<br>class ‘int’<br>type(1</em>1.0)<br>class ‘float’<br>type(2/2)<br>class ‘float’<br>type(2//2)<br>class ‘int’<br><strong>双斜杠是除完然后取整。</strong></p><h3 id="python的进制"><a href="#python的进制" class="headerlink" title="python的进制"></a>python的进制</h3><ul><li>0b表示二进制<br>0b11-&gt;3<br>0b10-&gt;2</li><li>0o表示8进制<br>0o10-&gt;8<br>0o11-&gt;9</li><li>0x表示16进制<br>0x10-&gt;16<br>0x11-&gt;17</li><li>bin（）方法完成其他进制转换成二进制</li><li>int（）方法将其他进制转换成十进制</li><li>hex（）方法将其他进制转换成16进制</li><li>oct（）方法将其他进制转换成8进制</li></ul><h3 id="python的bool的类型"><a href="#python的bool的类型" class="headerlink" title="python的bool的类型"></a>python的bool的类型</h3><ul><li>bool(1） true</li><li>bool(2)  true</li><li>bool(3)  true</li><li>bool(0)  false</li></ul><h3 id="python中为什么有单双引号"><a href="#python中为什么有单双引号" class="headerlink" title="python中为什么有单双引号"></a>python中为什么有单双引号</h3><ol><li>“let us go”</li><li>‘let us go’</li><li>“let’s go”</li><li>“let’s go”</li><li>“let\’s go”</li><li>“let’s go”</li></ol><ul><li>单双引号换行<ul><li>‘hello\world’,</li><li>“””hello world “””</li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li>“hello world”[0:-2]<br>‘hello wor’</li><li>“hello world”[1]<br>‘e’</li><li>“hello world”[2]<br>‘l’</li><li>“hello world”[3]<br>‘l’</li><li>“hello world”[4]<br>‘o’</li><li>r’dfdfdf’或者R’dfdfdffd’原始字符串<h3 id="python中的列表"><a href="#python中的列表" class="headerlink" title="python中的列表"></a>python中的列表</h3></li></ol><ul><li>list里面可以存放任意类型<br>1.输出：[1, 2, 3, ‘1’, True, False]<br> 结果：[1,2,3,’1’,True,False]</li><li>list里面读取字符</li></ul><ol><li>[“第一技能”,”第二季能”,”第三季能”,”第四技能”][1:3]<br> [‘第二季能’, ‘第三季能’]</li></ol><ul><li>list添加元素<br>[“第一技能”,”第二季能”,”第三季能”,”第四技能”]+[“点燃”,”虚弱”]</li></ul><h3 id="python中的元组"><a href="#python中的元组" class="headerlink" title="python中的元组"></a>python中的元组</h3><p>-表示形式</p><ol><li>>&gt;&gt; (1,2,3,4,5)<pre><code>(1, 2, 3, 4, 5)</code></pre></li><li>>&gt;&gt; type((1,2,3,4,5))<pre><code>&lt;class &apos;tuple&apos;&gt;</code></pre></li></ol><ul><li>对于只含有一个元素的元组</li></ul><ol><li>>&gt;&gt; type((1))<pre><code>&lt;class &apos;int&apos;&gt;</code></pre></li><li>>&gt;&gt; type((‘1’))<pre><code>&lt;class &apos;str&apos;&gt;</code></pre></li><li>>&gt;&gt; type((‘False’))<pre><code>&lt;class &apos;str&apos;&gt;</code></pre></li><li>>&gt;&gt; type((False))<pre><code>&lt;class &apos;bool&apos;&gt;</code></pre><strong>对于一个元素的元组，python会把他当成一个数学运算。</strong></li></ol><p><strong>元组，序列，列表都称之为序列</strong></p><h3 id="python中的序列"><a href="#python中的序列" class="headerlink" title="python中的序列"></a>python中的序列</h3><ol><li>判断是否有元素在里面<br>>&gt;&gt; 3 in [1,2,3,4,5,6]<br>True<br>>&gt;&gt; 3 not in [1,2,3,4,5,6]<br>False</li><li>对元组进行判断<ol><li>>&gt;&gt; len([1,3,5,4,6,8])<br>6</li><li>>&gt;&gt; max([1,3,5,4,6,8])<br>8</li><li>>&gt;&gt; min([1,3,5,4,6,8])<br>1</li><li>>&gt;&gt; min(‘helloword’)<br>‘d’</li><li>>&gt;&gt; max(‘helloword’)<br>‘w’</li></ol></li><li>用ord（’’）读取ascall值<ol><li>>&gt;&gt; ord(‘ ‘)<br>32</li><li>>&gt;&gt; ord(‘w’)<br>119</li><li>>&gt;&gt; ord(‘r’)<br>114</li></ol></li></ol><h3 id="python中的集合"><a href="#python中的集合" class="headerlink" title="python中的集合"></a>python中的集合</h3><ul><li>集合是无序的，所以他没有序列的</li><li><p>集合具有不重复性</p></li><li><p>>&gt;&gt; {1,2,3,4,4,5,6}<br>  {1, 2, 3, 4, 5, 6}</p></li><li>>&gt;&gt; len({1,2,3,4,5})<br>5</li><li>>&gt;&gt; 1 in {1,2,3,4}<br>True</li><li>>&gt;&gt; 1 not in {1,2,3,4}<br>False</li><li>>&gt;&gt; {1,2,3,4,5,6}-{1,2}<br>{3, 4, 5, 6}</li><li>>&gt;&gt; {1,2,3,4,5,6}&amp;{3,4}<br>{3, 4}</li><li>>&gt;&gt; {1,2,3,4,5,6}|{3,4,7}<br>{1, 2, 3, 4, 5, 6, 7}</li><li>>&gt;&gt; type({})<br>class ‘dict’</li><li>>&gt;&gt; type(set())<br>class ‘set’</li><li>>&gt;&gt; len(set())<br>0</li></ul><h3 id="python中的字典"><a href="#python中的字典" class="headerlink" title="python中的字典"></a>python中的字典</h3><ul><li>字典 key-value</li></ul><ol><li>>&gt;&gt; {‘Q’:’新月打击’,’W’:’苍白值瀑’,’E’:’月之降临’,’R’:’月神冲刺’}[‘Q’]<br>‘新月打击’</li></ol><ul><li>value可以是任意类型，key是只能唯一的基本类型。<br><img src="https://i.imgur.com/B1nzF66.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一行代码&quot;&gt;&lt;a href=&quot;#第一行代码&quot; class=&quot;headerlink&quot; title=&quot;第一行代码&quot;&gt;&lt;/a&gt;第一行代码&lt;/h2&gt;&lt;h3 id=&quot;python的数据类型&quot;&gt;&lt;a href=&quot;#python的数据类型&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="python" scheme="https://jzygaga.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://jzygaga.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>快速过桥</title>
    <link href="https://jzygaga.github.io/2019/01/07/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%BF%AB%E9%80%9F%E8%BF%87%E6%A1%A5/"/>
    <id>https://jzygaga.github.io/2019/01/07/蓝桥杯-快速过桥/</id>
    <published>2019-01-07T03:41:51.000Z</published>
    <updated>2019-01-07T04:55:10.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速过桥"><a href="#快速过桥" class="headerlink" title="快速过桥"></a>快速过桥</h2><ul><li><strong>问题描述：</strong>n个人的队伍想在晚上通过一座大桥。任何时间最多有2人通过，每组必须有一个手电筒。很可怜，这n个人只有一个手电筒可用，因此必须合理地安排，让手电筒能回到另一端，这样才能让更多人通过大桥。每个人有不同的速度，编组后，一个组的速度等于慢的那个人的速度。你的任务是实现一种策略，让所有人在最短时间内通过。</li><li><strong>样例输入</strong><br>【样例输入】<br>  1<br>  4<br>  1<br>  2<br>  5<br>  10<br>【样例输出】<br>  17<br>  1 2<br>  1<br>  5 10<br>  2<br>  1 2</li><li><a href="https://blog.csdn.net/qq_41061455/article/details/79536991" target="_blank" rel="noopener">https://blog.csdn.net/qq_41061455/article/details/79536991</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;快速过桥&quot;&gt;&lt;a href=&quot;#快速过桥&quot; class=&quot;headerlink&quot; title=&quot;快速过桥&quot;&gt;&lt;/a&gt;快速过桥&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;问题描述：&lt;/strong&gt;n个人的队伍想在晚上通过一座大桥。任何时间最多有2人通过，每组必须有
      
    
    </summary>
    
      <category term="蓝桥杯" scheme="https://jzygaga.github.io/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    
      <category term="智力题" scheme="https://jzygaga.github.io/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列</title>
    <link href="https://jzygaga.github.io/2019/01/06/%E5%89%91%E6%8C%87offer-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://jzygaga.github.io/2019/01/06/剑指offer-斐波那契数列/</id>
    <published>2019-01-06T06:34:09.000Z</published>
    <updated>2019-01-06T09:37:25.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><ul><li>描述<br><strong>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 </strong></li><li>代码<pre><code>public int Fibonacci1(int n) {      if(n==1)          return 1;      if(n==2)          return 1;        int[] arr=new int[n];        arr[0]=1;        arr[1]=1;        for(int i=2;i&lt;n;i++) {            arr[i]=arr[i-1]+arr[i-2];        }        return arr[n-1];    }</code></pre></li><li><p>代码</p><pre><code>import java.util.HashMap;import java.util.Map;public class Solution {    private Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();    public int Fibonacci(int n) {         if(n==1)           return 1;         if(n==2)          return 1;         if(map.get(n)!=null)             return map.get(n);        map.put(n, Fibonacci(n-1)+Fibonacci(n-2));        return map.get(n);    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;描述&lt;br&gt;&lt;strong&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Powerful Integers</title>
    <link href="https://jzygaga.github.io/2019/01/06/leetcode-970.%20Powerful%20Integers/"/>
    <id>https://jzygaga.github.io/2019/01/06/leetcode-970. Powerful Integers/</id>
    <published>2019-01-06T05:57:10.000Z</published>
    <updated>2019-01-06T06:09:29.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="970-Powerful-Integers"><a href="#970-Powerful-Integers" class="headerlink" title="970. Powerful Integers"></a>970. Powerful Integers</h2><ul><li><strong>描述：</strong>Given two non-negative integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &gt;= 0 and j &gt;= 0.</li><li>例子<ul><li>例子1<br>   Input: x = 2, y = 3, bound = 10<pre><code>Output: [2,3,4,5,7,9,10]Explanation: 2 = 2^0 + 3^03 = 2^1 + 3^04 = 2^0 + 3^15 = 2^1 + 3^17 = 2^2 + 3^19 = 2^3 + 3^010 = 2^0 + 3^2</code></pre></li></ul></li><li><p>代码</p><ul><li><p>while</p><pre><code>class Solution {      public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) {         int maxV=Math.max(x, y);         int minV=Math.min(x, y);         int sum;         int sumMaxV=1;         int sumMinV=1;        Set&lt;Integer&gt; set=new HashSet&lt;&gt;();        //3         while(sumMaxV&lt;=bound) {             sumMinV=1;             while(sumMinV&lt;=(bound-sumMaxV)) {                 sum=sumMaxV+sumMinV;                // if(sum&gt;bound)                //     break;     while()条件已经判断了                 set.add(sum);               if(minV==1)                     break;                 sumMinV*=minV;             }             sumMaxV*=maxV;              if(maxV==1)                     break;         }         return new ArrayList&lt;&gt;(set);     }}</code></pre></li><li><p>for</p><pre><code>    public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) {        Set&lt;Integer&gt; result = new HashSet&lt;&gt;();        for (int a = 1; a &lt; bound; a *= x) {            for (int b = 1; a + b &lt;= bound; b *= y) {                result.add(a + b);                if (y == 1) {                    break;                }            }            if (x == 1) {                break;            }        }        return new ArrayList&lt;&gt;(result);    }}</code></pre></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;970-Powerful-Integers&quot;&gt;&lt;a href=&quot;#970-Powerful-Integers&quot; class=&quot;headerlink&quot; title=&quot;970. Powerful Integers&quot;&gt;&lt;/a&gt;970. Powerful Integers
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="数组" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>图结构</title>
    <link href="https://jzygaga.github.io/2019/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/"/>
    <id>https://jzygaga.github.io/2019/01/05/数据结构-图/</id>
    <published>2019-01-05T03:01:15.000Z</published>
    <updated>2019-01-05T13:36:37.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图结构"><a href="#图结构" class="headerlink" title="图结构"></a>图结构</h2><ul><li>图的分类<ul><li>有向图，无向图<ul><li>边上有方向</li><li>边上无方向</li></ul></li><li>有权图，无权图<ul><li>有权图，边上有值。</li><li>无权图，边上无值。</li></ul></li></ul></li><li>图的连通性<ul><li>判断图之间是否连通</li><li>连通分量</li></ul></li><li>边<ul><li>自环边</li><li>平行边<br><img src="https://i.imgur.com/MoWEPbr.png" alt=""></li></ul></li></ul><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><ul><li><p>邻接矩阵<br><img src="https://i.imgur.com/TcAYKKm.png" alt=""></p><pre><code>package graphic;    /**     * 密集矩阵用邻接矩阵     * @author 59842     *     */    public class DenseGraph {        //有多少个定点        private int n;        //有多少个边        private int m;        //是否有向//true表示有向图        private boolean directed;        //存储图的有向结构        private boolean[][] g;        public DenseGraph(int n, boolean directed) {            this.n=n;            this.m=0;            this.directed=directed;            g=new boolean [n][n];        }        public void addEdge(int v,int w) {            if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n)                throw new IllegalArgumentException(&quot;边超出了范围&quot;);            if(hasEdge(v,w))                return ;            g[v][w]=true;            if(!directed)                //不是有向图                g[w][v]=true;            m++;        }        private boolean hasEdge(int v, int w) {            if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n)                throw new IllegalArgumentException(&quot;边超出了范围&quot;);            return g[w][v]=false;        }        public int getV() {            return n;        }        public int getE() {            return m;        }    }</code></pre></li><li><p>邻接表<br><img src="https://i.imgur.com/IOng9e6.png" alt=""></p></li><li><p>完全图</p><ul><li>适用的场景，每个电影的相似程度。有权图<br><strong>邻接表适合表示稀疏图，邻接矩阵适合表示稠密图</strong></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;图结构&quot;&gt;&lt;a href=&quot;#图结构&quot; class=&quot;headerlink&quot; title=&quot;图结构&quot;&gt;&lt;/a&gt;图结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;图的分类&lt;ul&gt;
&lt;li&gt;有向图，无向图&lt;ul&gt;
&lt;li&gt;边上有方向&lt;/li&gt;
&lt;li&gt;边上无方向&lt;/li&gt;
&lt;/ul&gt;
      
    
    </summary>
    
      <category term="图结构" scheme="https://jzygaga.github.io/categories/%E5%9B%BE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="https://jzygaga.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈实现队列</title>
    <link href="https://jzygaga.github.io/2019/01/04/%E5%89%91%E6%8C%87offer-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://jzygaga.github.io/2019/01/04/剑指offer-用两个栈实现队列/</id>
    <published>2019-01-04T03:08:18.000Z</published>
    <updated>2019-01-04T03:13:44.887Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong></p><ul><li><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><ul><li><p>自己解</p><pre><code>import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();     public void push(int node) {           stack1.push(node);    }    public int pop() {        while(!stack1.isEmpty()) {            stack2.push(stack1.pop());        }        Integer toPop = stack2.pop();        while(!stack2.isEmpty()) {            stack1.push(stack2.pop());        }        return toPop;    }}</code></pre></li><li><p>渐优解</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;自己解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import java.util.Stac
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="栈" scheme="https://jzygaga.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://jzygaga.github.io/2019/01/04/%E5%89%91%E6%8C%87offer-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://jzygaga.github.io/2019/01/04/剑指offer-重建二叉树/</id>
    <published>2019-01-04T02:47:53.000Z</published>
    <updated>2019-01-04T02:52:54.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h2><p><strong>题目描述</strong></p><ul><li><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><pre><code>/** * Definition for binary tree * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {     public TreeNode reConstructBinaryTree(int [] pre,int [] in) {        if(pre==null||in==null||pre.length!=in.length)            return null;       return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);    }    private TreeNode reConstructBinaryTree(int[] pre,int pStart,int pEnd,int[] in,int iStart,int iEnd){        //一般性问题        if(pStart&gt;pEnd)            return null;        //创建根节点        TreeNode root=new TreeNode(pre[pStart]);        //找到中序遍历中的位置        int loc;        for(loc=0;loc&lt;in.length;loc++){            if(in[loc]==pre[pStart]){                break;            }        }        //计算左右子树节点的个数。        int len=loc-iStart;        root.left=reConstructBinaryTree(pre,pStart+1,pStart+len,in,iStart,iStart+len-1);        root.right=reConstructBinaryTree(pre,pStart+len+1,pEnd,in,iStart+len+1,iEnd);        return root;    }}</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;重建二叉树&quot;&gt;&lt;a href=&quot;#重建二叉树&quot; class=&quot;headerlink&quot; title=&quot;重建二叉树&quot;&gt;&lt;/a&gt;重建二叉树&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://jzygaga.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="二叉树" scheme="https://jzygaga.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>234. Palindrome Linked List</title>
    <link href="https://jzygaga.github.io/2019/01/03/leetcode-%E5%8D%95%E9%93%BE%E8%A1%A8-234.%20Palindrome%20Linked%20List/"/>
    <id>https://jzygaga.github.io/2019/01/03/leetcode-单链表-234. Palindrome Linked List/</id>
    <published>2019-01-03T06:32:36.000Z</published>
    <updated>2019-01-03T06:38:51.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a>Palindrome Linked List</h2><ul><li>描述：<strong>Given a singly linked list, determine if it is a palindrome.</strong></li><li>例子：<ul><li>Input: 1-&gt;2 ，Output: false </li><li>Input: 1-&gt;2-&gt;2-&gt;1，Output: true</li></ul></li></ul><p><strong>代码1</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Palindrome-Linked-List&quot;&gt;&lt;a href=&quot;#Palindrome-Linked-List&quot; class=&quot;headerlink&quot; title=&quot;Palindrome Linked List&quot;&gt;&lt;/a&gt;Palindrome Linked Li
      
    
    </summary>
    
      <category term="leetcode" scheme="https://jzygaga.github.io/categories/leetcode/"/>
    
    
      <category term="单链表" scheme="https://jzygaga.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
</feed>
