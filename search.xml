<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>234. Palindrome Linked List</title>
      <link href="/2019/01/03/leetcode-%E5%8D%95%E9%93%BE%E8%A1%A8-234.%20Palindrome%20Linked%20List/"/>
      <url>/2019/01/03/leetcode-%E5%8D%95%E9%93%BE%E8%A1%A8-234.%20Palindrome%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Palindrome-Linked-List"><a href="#Palindrome-Linked-List" class="headerlink" title="Palindrome Linked List"></a>Palindrome Linked List</h2><ul><li>描述：<strong>Given a singly linked list, determine if it is a palindrome.</strong></li><li>例子：<ul><li>Input: 1-&gt;2 ，Output: false </li><li>Input: 1-&gt;2-&gt;2-&gt;1，Output: true</li></ul></li></ul><p><strong>代码1</strong></p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>206. Reverse Linked List</title>
      <link href="/2019/01/03/leetcode-206.%20Reverse%20Linked%20List/"/>
      <url>/2019/01/03/leetcode-206.%20Reverse%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="Reverse-Linked-List"><a href="#Reverse-Linked-List" class="headerlink" title="Reverse Linked List"></a>Reverse Linked List</h2><p><strong>Reverse a singly linked list.</strong><br><strong> Example:</strong></p><pre><code>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULLOutput: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre><p><strong>代码</strong></p><ul><li><p>迭代的代码</p><pre><code>class Solution {     public ListNode reverseList(ListNode head) {        ListNode reverseNode=null;        ListNode cur=head;        ListNode toDeal=null;        while(cur!=null) {            //拿到待处理的节点            toDeal =cur;            cur=cur.next;            //拿到一边进行连接            toDeal.next=reverseNode;            reverseNode=toDeal;        }        return reverseNode;    }}</code></pre></li></ul><ul><li><p>递归的代码<br><strong>代码一</strong></p><pre><code>class Solution {     public ListNode reverseList(ListNode head) {        if(head==null||head.next==null)            return head;        return toReverse(head,null);    }    private ListNode toReverse(ListNode head, ListNode reverse) {        if(head==null) {            return reverse;        }        ListNode cur=head.next;        //与另一个链表相连接        head.next=reverse;        //        reverse=head;        return toReverse(cur,reverse);    }}</code></pre></li></ul><p><strong>代码二</strong></p><pre><code>public ListNode reverseList(ListNode head) {    if(head==null||head.next==null)        return head;    ListNode newHead= reverseList(head.next);    //两个借点之间的链接进行翻转    head.next.next=head;    head.next=null;    return newHead;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Middle of the Linked List</title>
      <link href="/2019/01/03/leetcode-876.%20Middle%20of%20the%20Linked%20List/"/>
      <url>/2019/01/03/leetcode-876.%20Middle%20of%20the%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<h2 id="876-Middle-of-the-Linked-List"><a href="#876-Middle-of-the-Linked-List" class="headerlink" title="876. Middle of the Linked List"></a>876. Middle of the Linked List</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><strong> Given a non-empty, singly linked list with head node head, return a middle node of linked list.<br>if there are two middle nodes, return the second middle node. </strong></p><ul><li>Example 1:<br>  Input: [1,2,3,4,5]<br>  Output: Node 3 from this list (Serialization: [3,4,5])<br>  The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>  Note that we returned a ListNode object ans, such that:<br>  ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</li><li><p>Example 2：<br>  Input: [1,2,3,4,5]<br>  Output: Node 3 from this list (Serialization: [3,4,5])<br>  The returned node has value 3.  (The judge’s serialization of this node is [3,4,5]).<br>  Note that we returned a ListNode object ans, such that:<br>  ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.</p><h3 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h3><pre><code>    class Solution {    public ListNode middleNode(ListNode head) {        ListNode node=head;        int i=0;        while(node!=null) {             i++;             node=node.next;        }        int loc=i/2+1;        i=1;        ListNode node1=head;        while(i&lt;loc) {            node1=node1.next;            i++;        }        return node1;    }}</code></pre><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><pre><code>public ListNode middleNode(ListNode head) {    ListNode listNode = new ListNode(0);    ListNode fast=head;    ListNode low=head;    while(fast!=null&amp;&amp;fast.next!=null) {        fast=fast.next.next;        low=low.next;    }    return low.next;}</code></pre><h3 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a>代码三</h3><pre><code>  class Solution {    public ListNode middleNode(ListNode head) {        ListNode fast=head;        ListNode low=head;        //对比2方法，假装自己先跑了两步         if(fast!=null&amp;&amp;fast.next!=null){            fast=fast.next.next;        }else{            return low;        }        while(fast!=null&amp;&amp;fast.next!=null) {            fast=fast.next.next;            low=low.next;        }        return low.next;    }}</code></pre><h3 id="代码四"><a href="#代码四" class="headerlink" title="代码四"></a>代码四</h3><pre><code>public ListNode middleNode(ListNode head) {    ListNode fast=head;    ListNode low=head;    //对比2方法，假装自己先跑了两步    if(head==null&amp;&amp;head.next==null)        return head;    while(fast!=null&amp;&amp;fast.next!=null) {        fast=fast.next.next;        low=low.next;    }    return low;}</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二维数组中的查找</title>
      <link href="/2019/01/02/%E5%89%91%E6%8C%87offer/"/>
      <url>/2019/01/02/%E5%89%91%E6%8C%87offer/</url>
      
        <content type="html"><![CDATA[<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h2><p><strong>描述：</strong></p><ul><li><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><strong>代码</strong></p><pre><code>public class Solution {    public boolean Find(int target, int [][] array) {        int y=0;        int x=array.length-1;        int row=array.length-1;        int col=array[0].length-1;        while((0&lt;=x&amp;&amp;x&lt;=col)&amp;&amp;(0&lt;=y&amp;&amp;y&lt;=row)){            if(array[x][y]==target)                return true;            if(array[x][y]&lt;target){                y++;               continue;             }            if(array[x][y]&gt;target){                x--;               continue;            }        }        return false;    }}</code></pre><h2 id="注意数组根据先后赋值，排列是从上到下来的"><a href="#注意数组根据先后赋值，排列是从上到下来的" class="headerlink" title="注意数组根据先后赋值，排列是从上到下来的"></a>注意数组根据先后赋值，排列是从上到下来的</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> 剑指offer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反射</title>
      <link href="/2019/01/02/java-%E5%8F%8D%E5%B0%84/"/>
      <url>/2019/01/02/java-%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h2 id="对方的付费"><a href="#对方的付费" class="headerlink" title="对方的付费"></a>对方的付费</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂模式</title>
      <link href="/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂模式</title>
      <link href="/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E4%BA%A7%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/01/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E4%BA%A7%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红黑树</title>
      <link href="/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><ul><li><p>红黑树定义</p><ul><li>算法导论的定义</li></ul></li><li><p>满二叉树</p><ul><li>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空</li></ul></li><li>AVL<ul><li>定义每一个节点的高度</li><li>计算平衡因子 <ul><li>定义： 每个节点的平衡因子等于左子树减去右子树的差</li><li>作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的<br><img src="https://i.imgur.com/gutLgG7.png" width="200" height="200" div="" align="right"></li></ul></li><li>AVL的左旋转右旋转<ul><li>当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。<br>*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。</li></ul></li></ul></li></ul><pre><code>package AVLTree;import java.util.ArrayList;public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; {    private class Node{        public K key;        public V value;        public Node left, right;        public int height;        public Node(K key, V value){            this.key = key;            this.value = value;            left = null;            right = null;            height = 1;        }    }    private Node root;    private int size;    public AVLTree(){        root = null;        size = 0;    }    public int getSize(){        return size;    }    public boolean isEmpty(){        return size == 0;    }    // 获得节点node的高度    private int getHeight(Node node){        if(node == null)            return 0;        return node.height;    }    // 获得节点node的平衡因子    private int getBalanceFactor(Node node){        if(node == null)            return 0;        return getHeight(node.left) - getHeight(node.right);    }    // 向二分搜索树中添加新的元素(key, value)    public void add(K key, V value){        root = add(root, key, value);    }    // 向以node为根的二分搜索树中插入元素(key, value)，递归算法    // 返回插入新节点后二分搜索树的根    private Node add(Node node, K key, V value){        if(node == null){            size ++;            return new Node(key, value);        }        if(key.compareTo(node.key) &lt; 0)            node.left = add(node.left, key, value);        else if(key.compareTo(node.key) &gt; 0)            node.right = add(node.right, key, value);        else // key.compareTo(node.key) == 0            node.value = value;        // 更新height        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));                 int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0)            return rightRotate(node);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0)            return leftRotate(node);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) {            //先进行左旋            node.left= leftRotate(node.left);            return rightRotate(node);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) {            node.right=rightRotate(node.right);            return leftRotate(node);        }        return node;    }    //对节点进行左旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          T1  x   向右旋转(y),左侧过高不平衡                   y    z    //             / \    ----------------------&gt;               / \   / \    //          T2  z                                     T1 T2 T3 T4    //             / \   //                T4  T3    //    private Node leftRotate(Node y) {        Node x=y.right;        Node T2=x.right;        //向右旋转过程        x.left=y;        y.right=T2;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    //对节点进行右旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          x   T4    向右旋转(y),左侧过高不平衡                   z    y    //         / \      ----------------------&gt;               / \   / \    //      z   T3                                        T1 T2 T3 T4    //     / \    //      T1  T2    // 返回以node为根节点的二分搜索树中，key所在的节点    private Node rightRotate(Node y) {        Node x=y.left;        Node T3=x.right;        //向右旋转过程        x.right=y;        y.left=T3;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    private Node getNode(Node node, K key){        if(node == null)            return null;        if(key.equals(node.key))            return node;        else if(key.compareTo(node.key) &lt; 0)            return getNode(node.left, key);        else // if(key.compareTo(node.key) &gt; 0)            return getNode(node.right, key);    }    public boolean contains(K key){        return getNode(root, key) != null;    }    public V get(K key){        Node node = getNode(root, key);        return node == null ? null : node.value;    }    public void set(K key, V newValue){        Node node = getNode(root, key);        if(node == null)            throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;);        node.value = newValue;    }    // 返回以node为根的二分搜索树的最小值所在的节点    private Node minimum(Node node){        if(node.left == null)            return node;        return minimum(node.left);    }    // 删除掉以node为根的二分搜索树中的最小节点    // 返回删除节点后新的二分搜索树的根    private Node removeMin(Node node){        if(node.left == null){            Node rightNode = node.right;            node.right = null;            size --;            return rightNode;        }        node.left = removeMin(node.left);        return node;    }    // 从二分搜索树中删除键为key的节点    public V remove(K key){        Node node = getNode(root, key);        if(node != null){            root = remove(root, key);            return node.value;        }        return null;    }    private Node remove(Node node, K key){        if( node == null )            return null;        Node retNode;        if( key.compareTo(node.key) &lt; 0 ){            node.left = remove(node.left , key);            retNode= node;        }        else if(key.compareTo(node.key) &gt; 0 ){            node.right = remove(node.right, key);            retNode= node;        }        else{   // key.compareTo(node.key) == 0            // 待删除节点左子树为空的情况            if(node.left == null){                Node rightNode = node.right;                node.right = null;                size --;                retNode= rightNode;            }else if(node.right == null){ // 待删除节点右子树为空的情况                Node leftNode = node.left;                node.left = null;                size --;                retNode= leftNode;            }else {                // 待删除节点左右子树均不为空的情况                // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点                // 用这个节点顶替待删除节点的位置                Node successor = minimum(node.right);                successor.right = remove(node.right,successor.key);                successor.left = node.left;                node.left = node.right = null;                retNode= successor;            }        }        if(retNode==null)            return retNode;       // 更新height        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));                 int balanceFactor = getBalanceFactor(retNode);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0)            return rightRotate(retNode);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0)            return leftRotate(retNode);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) {            //先进行左旋            node.left= leftRotate(retNode.left);            return rightRotate(retNode);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) {            retNode.right=rightRotate(retNode.right);            return leftRotate(retNode);        }        return retNode;    }    public static void main(String[] args){        System.out.println(&quot;Pride and Prejudice&quot;);        ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) {            System.out.println(&quot;Total words: &quot; + words.size());            AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;();            for (String word : words) {                if (map.contains(word))                    map.set(word, map.get(word) + 1);                else                    map.add(word, 1);            }            System.out.println(&quot;Total different words: &quot; + map.getSize());            System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;));            System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;));            System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST());            System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced());            for(String word:words) {                map.remove(word);                if(!map.isBalanced()||!map.isBST()) {                    throw new RuntimeException(&quot;error！&quot;);                }            }        }        System.out.println();    }    public boolean isBST() {        //BST在中序边遍历是从小到大来的        ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;();        inOrder(root,keys);        for(int i=1;i&lt;keys.size();i++)             //注意i-1            if(keys.get(i-1).compareTo(keys.get(i))&gt;0)                return false;        return true;    }    private void inOrder(Node root, ArrayList&lt;K&gt; keys) {        if(root==null)            return ;        inOrder(root.left, keys);        keys.add(root.key);        inOrder(root.right, keys);    }    //判断二叉树是否是一颗平衡二叉树    public boolean isBalanced() {        return isBalanced(root);    }    //判断以Node为根的二叉树是平衡二叉树，递归算法    public boolean isBalanced(Node node) {        if(node==null)            return true;        int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor)&gt;1)            return false;        return isBalanced(node.left)&amp;&amp;isBalanced(node.right);    }}</code></pre><figure class="third"><br>   <img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><br>    <img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br>   <img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br></figure><p><img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/DFmJgAX.png" width="300" height="200" div="" align="right"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红黑树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AVL树</title>
      <link href="/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL%E6%A0%91/"/>
      <url>/2019/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-AVL%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><ul><li>平衡二叉树的定义<ul><li>对于任意一个节点，左子树和右子树的高度差不能超过1</li><li>AVL树有着自己的平衡性，所以在自己的增加和删除，不会退化成一个链表</li></ul></li><li>满二叉树<br>   <img src="https://i.imgur.com/vpxDXic.png" width="100" height="100" div="" align="right"><ul><li>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空</li></ul></li><li>AVL<ul><li>定义每一个节点的高度</li><li>计算平衡因子 <ul><li>定义： 每个节点的平衡因子等于左子树减去右子树的差</li><li>作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的<br><img src="https://i.imgur.com/gutLgG7.png" width="200" height="200" div="" align="right"></li></ul></li><li>AVL的左旋转右旋转<ul><li>当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。<br>*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。</li></ul></li></ul></li></ul><pre><code>package AVLTree;import java.util.ArrayList;public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; {    private class Node{        public K key;        public V value;        public Node left, right;        public int height;        public Node(K key, V value){            this.key = key;            this.value = value;            left = null;            right = null;            height = 1;        }    }    private Node root;    private int size;    public AVLTree(){        root = null;        size = 0;    }    public int getSize(){        return size;    }    public boolean isEmpty(){        return size == 0;    }    // 获得节点node的高度    private int getHeight(Node node){        if(node == null)            return 0;        return node.height;    }    // 获得节点node的平衡因子    private int getBalanceFactor(Node node){        if(node == null)            return 0;        return getHeight(node.left) - getHeight(node.right);    }    // 向二分搜索树中添加新的元素(key, value)    public void add(K key, V value){        root = add(root, key, value);    }    // 向以node为根的二分搜索树中插入元素(key, value)，递归算法    // 返回插入新节点后二分搜索树的根    private Node add(Node node, K key, V value){        if(node == null){            size ++;            return new Node(key, value);        }        if(key.compareTo(node.key) &lt; 0)            node.left = add(node.left, key, value);        else if(key.compareTo(node.key) &gt; 0)            node.right = add(node.right, key, value);        else // key.compareTo(node.key) == 0            node.value = value;        // 更新height        node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));                 int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0)            return rightRotate(node);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0)            return leftRotate(node);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) {            //先进行左旋            node.left= leftRotate(node.left);            return rightRotate(node);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) {            node.right=rightRotate(node.right);            return leftRotate(node);        }        return node;    }    //对节点进行左旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          T1  x   向右旋转(y),左侧过高不平衡                   y    z    //             / \    ----------------------&gt;               / \   / \    //          T2  z                                     T1 T2 T3 T4    //             / \   //                T4  T3    //    private Node leftRotate(Node y) {        Node x=y.right;        Node T2=x.right;        //向右旋转过程        x.left=y;        y.right=T2;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    //对节点进行右旋操作，返回旋转后的新节点X    //            y                                             x    //           / \                                           /  \    //          x   T4    向右旋转(y),左侧过高不平衡                   z    y    //         / \      ----------------------&gt;               / \   / \    //      z   T3                                        T1 T2 T3 T4    //     / \    //      T1  T2    // 返回以node为根节点的二分搜索树中，key所在的节点    private Node rightRotate(Node y) {        Node x=y.left;        Node T3=x.right;        //向右旋转过程        x.right=y;        y.left=T3;        //更新height,只有x,y的位置移动了        y.height=Math.max(getHeight(y.left), getHeight(y.right));        x.height=Math.max(getHeight(x.left), getHeight(x.right));        return y;    }    private Node getNode(Node node, K key){        if(node == null)            return null;        if(key.equals(node.key))            return node;        else if(key.compareTo(node.key) &lt; 0)            return getNode(node.left, key);        else // if(key.compareTo(node.key) &gt; 0)            return getNode(node.right, key);    }    public boolean contains(K key){        return getNode(root, key) != null;    }    public V get(K key){        Node node = getNode(root, key);        return node == null ? null : node.value;    }    public void set(K key, V newValue){        Node node = getNode(root, key);        if(node == null)            throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;);        node.value = newValue;    }    // 返回以node为根的二分搜索树的最小值所在的节点    private Node minimum(Node node){        if(node.left == null)            return node;        return minimum(node.left);    }    // 删除掉以node为根的二分搜索树中的最小节点    // 返回删除节点后新的二分搜索树的根    private Node removeMin(Node node){        if(node.left == null){            Node rightNode = node.right;            node.right = null;            size --;            return rightNode;        }        node.left = removeMin(node.left);        return node;    }    // 从二分搜索树中删除键为key的节点    public V remove(K key){        Node node = getNode(root, key);        if(node != null){            root = remove(root, key);            return node.value;        }        return null;    }    private Node remove(Node node, K key){        if( node == null )            return null;        Node retNode;        if( key.compareTo(node.key) &lt; 0 ){            node.left = remove(node.left , key);            retNode= node;        }        else if(key.compareTo(node.key) &gt; 0 ){            node.right = remove(node.right, key);            retNode= node;        }        else{   // key.compareTo(node.key) == 0            // 待删除节点左子树为空的情况            if(node.left == null){                Node rightNode = node.right;                node.right = null;                size --;                retNode= rightNode;            }else if(node.right == null){ // 待删除节点右子树为空的情况                Node leftNode = node.left;                node.left = null;                size --;                retNode= leftNode;            }else {                // 待删除节点左右子树均不为空的情况                // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点                // 用这个节点顶替待删除节点的位置                Node successor = minimum(node.right);                successor.right = remove(node.right,successor.key);                successor.left = node.left;                node.left = node.right = null;                retNode= successor;            }        }        if(retNode==null)            return retNode;       // 更新height        retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right));                 int balanceFactor = getBalanceFactor(retNode);        if(Math.abs(balanceFactor) &gt; 1)            System.out.println(&quot;unbalanced : &quot; + balanceFactor);        //平衡维护        //LL        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0)            return rightRotate(retNode);        //RR        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0)            return leftRotate(retNode);        //LR                      因为左子树的右子书过长        if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) {            //先进行左旋            node.left= leftRotate(retNode.left);            return rightRotate(retNode);        }        //RL                       因为右子树的左子树过长        if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) {            retNode.right=rightRotate(retNode.right);            return leftRotate(retNode);        }        return retNode;    }    public static void main(String[] args){        System.out.println(&quot;Pride and Prejudice&quot;);        ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();        if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) {            System.out.println(&quot;Total words: &quot; + words.size());            AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;();            for (String word : words) {                if (map.contains(word))                    map.set(word, map.get(word) + 1);                else                    map.add(word, 1);            }            System.out.println(&quot;Total different words: &quot; + map.getSize());            System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;));            System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;));            System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST());            System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced());            for(String word:words) {                map.remove(word);                if(!map.isBalanced()||!map.isBST()) {                    throw new RuntimeException(&quot;error！&quot;);                }            }        }        System.out.println();    }    public boolean isBST() {        //BST在中序边遍历是从小到大来的        ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;();        inOrder(root,keys);        for(int i=1;i&lt;keys.size();i++)             //注意i-1            if(keys.get(i-1).compareTo(keys.get(i))&gt;0)                return false;        return true;    }    private void inOrder(Node root, ArrayList&lt;K&gt; keys) {        if(root==null)            return ;        inOrder(root.left, keys);        keys.add(root.key);        inOrder(root.right, keys);    }    //判断二叉树是否是一颗平衡二叉树    public boolean isBalanced() {        return isBalanced(root);    }    //判断以Node为根的二叉树是平衡二叉树，递归算法    public boolean isBalanced(Node node) {        if(node==null)            return true;        int balanceFactor = getBalanceFactor(node);        if(Math.abs(balanceFactor)&gt;1)            return false;        return isBalanced(node.left)&amp;&amp;isBalanced(node.right);    }}</code></pre><figure class="third"><br>   <img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><br>    <img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br>   <img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br></figure><p><img src="https://i.imgur.com/iquZ6dV.png" width="300" height="200" div="" align="right"><img src="https://i.imgur.com/ALq9vrP.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/UeJYdx5.png" width="300" height="200" div="" align="right"><br><img src="https://i.imgur.com/DFmJgAX.png" width="300" height="200" div="" align="right"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AVL树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/2019/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/01/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络的分层"><a href="#计算机网络的分层" class="headerlink" title="计算机网络的分层"></a>计算机网络的分层</h2><ul><li>应用层：数据服务那个协议。</li><li>传输层：解决出错重传机制，</li><li>网络层：</li><li>数据链路层：</li><li>物理层：不可靠，不安全。<br><strong><br>发展时代：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层，<br>  不可靠，不安全。对数据的检验，数据服务那个协议，出错重传，应用协议。</strong><h2 id="网络传输的不可靠"><a href="#网络传输的不可靠" class="headerlink" title="网络传输的不可靠"></a>网络传输的不可靠</h2></li><li>丢包，重复包</li><li>出错</li><li>乱序<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2></li><li>问题提出<br><img src="https://i.imgur.com/lxcwUo2.png" alt=""></li><li>改进方案<br><img src="https://i.imgur.com/myI3wuL.png" alt=""></li><li>功能<ul><li>增加吞吐量，提高效率。</li></ul></li></ul><p><img src="https://i.imgur.com/ldNfkuL.png" alt=""></p><p><img src="https://i.imgur.com/oIyB5gf.png" alt=""><br><strong>一直等5的ack接受信号，整个接受5ack信号，接受到5返回整个接受ack信息。比如，未接受到5的ack信息，即使接收到6，7，8，9，10，11也不会发送ack信息</strong><br><img src="https://i.imgur.com/Ev0hBwa.png" alt=""></p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p><img src="https://i.imgur.com/IjZ2S3X.png" alt=""></p><ul><li>Src：IntelCor电脑 Dst:到路由器  链路层</li><li>Src:本机的ip地址 Dst:DNS服务器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>哈希表</title>
      <link href="/2018/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2018/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="导学"><a href="#导学" class="headerlink" title="导学"></a>导学</h2><h3 id="例子：387-First-Unique-Character-in-a-String"><a href="#例子：387-First-Unique-Character-in-a-String" class="headerlink" title="例子：387. First Unique Character in a String"></a>例子：387. First Unique Character in a String</h3><p><strong><br>Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.</strong></p><pre><code>Examples:s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2.</code></pre><p><strong>代码</strong></p><pre><code>class Solution {public int firstUniqChar(String s) {    int[] arr=new int[26];    for(int i=0;i&lt;s.length();i++){        arr[s.charAt(i)-&apos;a&apos;]++;    }    for(int i=0;i&lt;s.length();i++){        if(arr[s.charAt(i)-&apos;a&apos;]==1)            return i;    }    return -1;}}</code></pre><h2 id="什么是哈希表"><a href="#什么是哈希表" class="headerlink" title="什么是哈希表"></a>什么是哈希表</h2><ul><li>对于我们所关注的内容，比如例子中的字符串，我们建立字符串与我们想要得到值之间的索引的数据结构，我们称之为哈希表。</li><li>对于转换的过程我们称之为哈希函数。f(ch)=ch-‘a’;<ul><li>哈希函数就是把’键’转换成’索引’，如果不同的健对应相同值称之为哈希冲突。</li></ul></li><li>学习哈希表主要解决的问题：<ul><li>把键转换成索引</li><li>解决哈希冲突</li></ul></li><li>哈希表充分体现了算法设计思想：空间换时间。</li><li>通过健得到索引分越均匀越好。</li></ul><h2 id="哈希函数的设计"><a href="#哈希函数的设计" class="headerlink" title="哈希函数的设计"></a>哈希函数的设计</h2><ul><li>对于整型<ul><li>小范围的正整数正常使用</li><li>小范围的负整数进行偏移 -100~100-0~200</li><li>大整数 比如身份证号码<br><code>110108198512166666</code> 选择模一个素数。</li></ul></li><li>浮点型转换成整型<br>  <img src="https://i.imgur.com/yEOX2mI.png" alt=""></li><li>字符串 转成整型处理<ul><li>166 1<em>100+6</em>10+6*1</li><li>code c<em>26^3+o</em>26^2+d<em>26^1+e</em>26^0;</li><li>hash(code)=(c<em>B^3+o</em>B^2+d<em>B^1+e</em>B^0)%M;<br><img src="https://i.imgur.com/8fAdQtg.png" alt=""></li></ul></li><li>设计哈希函数的原则：<ul><li>一致性：如果a==b,则hash(a)==hash(b)</li><li>高效性：计算高校便捷</li><li>均匀性：哈希值均匀分布</li></ul></li></ul><h2 id="java中的hashcode"><a href="#java中的hashcode" class="headerlink" title="java中的hashcode"></a>java中的hashcode</h2><pre><code>package Hashtable;public class Student {    private int grade;    private int cls;    private String firstName;    private String lastName;    public Student(int grade, int cls, String firstName, String lastName) {        this.grade = grade;        this.cls = cls;        this.firstName = firstName;        this.lastName = lastName;    }    @Override    public int hashCode() {        int B=31;        int hash=0;        hash=hash*B+grade;        hash=hash*B+cls;        //不区分大小写。。        hash=hash*B+firstName.hashCode();        hash=hash*B+lastName.hashCode();        return hash;    }}</code></pre><h2 id="java中解决hashcode的方法-Seperate-Chaining"><a href="#java中解决hashcode的方法-Seperate-Chaining" class="headerlink" title="java中解决hashcode的方法 Seperate    Chaining"></a>java中解决hashcode的方法 Seperate    Chaining</h2><ul><li>(hashCode(k1)&amp;0x7fffffff)%M 根据hash值就算出索引</li><li><p>如果产生冲突了，就在后面添加一个，就相当于每个索引后面接一个链表，但是我们为了优化访问的速度，可以接一个红黑树。<br><img src="https://i.imgur.com/WKkYGA6.png" alt=""></p><ul><li>k2-&gt;k3相当于一个查找表。所以hashMap就相当于treemap的数组，HashSet相当于treeSet数组。</li></ul></li><li><p><strong>在java8之前每一个位置对应一个链表，java8之后一开始一个位置对应一个链表，当哈希冲突达到一定程度每一个位置从链表变成红黑树，在数量小的时候红黑树会进行反转等操作。</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lamda</title>
      <link href="/2018/12/29/java-lamda/"/>
      <url>/2018/12/29/java-lamda/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA8新特性——Lamda表达式"><a href="#JAVA8新特性——Lamda表达式" class="headerlink" title="JAVA8新特性——Lamda表达式"></a>JAVA8新特性——Lamda表达式</h1><h2 id="Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。"><a href="#Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。" class="headerlink" title="Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。"></a>Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。</h2><ul><li><p>先来看看传统的匿名内部类调用方式:</p><pre><code>interface MyInterface{    void lMethod();}public class Main {    public static void test(MyInterface myInterface){        myInterface.lMethod();    }    public static void main(String[] args) {        test(new MyInterface() {            @Override            public void lMethod() {                System.out.println(&quot;Hello World!&quot;);            }        });    }}</code></pre><p>　在主类中的这么几行代码，嵌套几层就为了输出一个Hello World！是不是很麻烦？但是由于java结构的完整性，我们还不得不那么做，现在JDK1.8来了。</p></li><li><p>再来看看使用Lamda表达式改写上面的代码：</p><pre><code> interface Myinterface{    void IMethod(); }public class Main {    public static void test(Myinterface myinterface){        myinterface.IMethod();    }    public static void main(String[] args) {        test(()-&gt; System.out.println(&quot;666&quot;));    }}</code></pre><p>这就是Lamda表达式语言，为了解决匿名内部类繁杂的操作而出现。</p></li><li><p>Lamda语法有三种形式：</p><ol><li>(参数) -&gt;单行语句；</li><li>(参数) -&gt;{多行语句}；</li><li><p>(参数) -&gt;表达式；<br>括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&gt;System.out.println(“Hello World!”) 前面的()代表void lMethod()方法，它没有入参，所以为空，-&gt;后面是一个单行语句；<br>如果-&gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;<br>-&gt;后面也可以是一个表达式，如：a+b等。</p><ul><li><p>(参数) -&gt;单行语句；</p><pre><code> interface MyInterface{    void lMethod(String str);}public class Main {    public static void test(MyInterface myInterface){        myInterface.lMethod(&quot;Hello World!&quot;);//设置参数内容    }    public static void main(String[] args) {        //首先在()中定义此表达式里面需要接收变量s，后面的单行语句中就可以使用该变量了        test((s)-&gt;System.out.println(s));    }}</code></pre></li><li><p>(参数) -&gt;多行语句；</p><pre><code> interface Myinterface{    void IMethod(String str); }public class Main {    public static void test(Myinterface myinterface){        myinterface.IMethod(&quot;hello word&quot;);    }    public static void main(String[] args) {        test((s)-&gt; {            s=s+s;            System.out.println(s);        });    }}</code></pre><p>　这样，Lamda表达式就看起来很简单了，有不有！</p></li></ul></li></ol></li></ul><p>　　匿名内部类，我们比较常用的地方在哪儿？线程类Thread，以前我们可能这样写：</p><h2 id="总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。"><a href="#总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。" class="headerlink" title="总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。"></a>总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lamda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并查集</title>
      <link href="/2018/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2018/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode</title>
      <link href="/2018/12/20/leetcode-211.%20Add%20and%20Search%20Word%20-%20Data%20structure%20design/"/>
      <url>/2018/12/20/leetcode-211.%20Add%20and%20Search%20Word%20-%20Data%20structure%20design/</url>
      
        <content type="html"><![CDATA[<h1 id="211-Add-and-Search-Word-Data-structure-design"><a href="#211-Add-and-Search-Word-Data-structure-design" class="headerlink" title="211. Add and Search Word - Data structure design"></a>211. Add and Search Word - Data structure design</h1><p><strong> Design a data structure that supports the following two operations:</strong> </p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><pre><code>addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class WordDictionary {private class Node{    public boolean isWord;    public TreeMap&lt;Character,Node&gt; next;public Node(boolean isWord) {    this.isWord=isWord;    next=new TreeMap&lt;&gt;();}public Node() {    this(false);}}private Node root;private int size;/** Initialize your data structure here. */public WordDictionary() {    root=new Node();    size=0;}/** Adds a word into the data structure. */public void addWord(String word) {    Node cur=root;    for(int i=0;i&lt;word.length();i++) {        char c = word.charAt(i);        if(cur.next.get(c)==null) {            cur.next.put(c, new Node());        }        cur=cur.next.get(c);    }    cur.isWord=true;    size++;}/** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */public boolean search(String word) {    int i=0;    Node cur=root;    return recurtionSearch(i,word,cur);}private boolean recurtionSearch(int i,String str,Node cur) {    if(i==str.length())        return cur.isWord;    char m=str.charAt(i);    if(m!=&apos;.&apos;) {        if(cur.next.get(m)==null)            return false;        return recurtionSearch(++i, str,cur.next.get(m));    }else {        //这个逻辑，就跳过点.这个位置        for(char c:cur.next.keySet())            if(recurtionSearch(++i, str,cur.next.get(c)))                return true;        return false;    }}//    public static void main(String[] args) {//        WordDictionary wordDictionary = new WordDictionary();//        wordDictionary.addWord(&quot;123&quot;);//        ;//        System.out.println(wordDictionary.search(&quot;.3&quot;));//    }}/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode</title>
      <link href="/2018/12/20/leetcode-208.%20Implement%20Trie%20(Prefix%20Tree)%20-%20%E5%89%AF%E6%9C%AC/"/>
      <url>/2018/12/20/leetcode-208.%20Implement%20Trie%20(Prefix%20Tree)%20-%20%E5%89%AF%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><p><strong> Implement a trie with insert, search, and startsWith methods. </strong> </p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // returns true<br>trie.search(“app”);     // returns false<br>trie.startsWith(“app”); // returns true<br>trie.insert(“app”);<br>trie.search(“app”);     // returns true *</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>class Trie {private class Node {    public boolean isWord;    public TreeMap&lt;Character, Node&gt; next;    public Node(boolean isWord) {        next = new TreeMap&lt;&gt;();        this.isWord = isWord;    }    public Node() {        this(false);    }}private Node root;private int size;/** Initialize your data structure here. */public Trie() {    root=new Node();    size=0;}/** Inserts a word into the trie. */public void insert(String word) {    Node cur=root;        for(int i=0;i&lt;word.length();i++) {            char c = word.charAt(i);            Node node = cur.next.get(c);            if(node==null)                cur.next.put(c, new Node());            cur=cur.next.get(c);        }        cur.isWord=true;}/** Returns if the word is in the trie. */public boolean search(String word) {    Node cur=root;        for(int i=0;i&lt;word.length();i++) {            char c = word.charAt(i);            if(cur.next.get(c)==null) {                return false;            }            cur=cur.next.get(c);        }    return cur.isWord;}/** * Returns if there is any word in the trie that starts with the given prefix. */public boolean startsWith(String prefix) {    Node cur=root;    for(int i=0;i&lt;prefix.length();i++) {        char c = prefix.charAt(i);        if(cur.next.get(c)==null) {            return false;        }        cur=cur.next.get(c);    }    return true;}//    public static void main(String[] args) {//        String[] arr= {&quot;Trie&quot;,&quot;insert&quot;,&quot;search&quot;,&quot;startWith&quot;,&quot;insert&quot;,&quot;search&quot;};//        Trie trie = new Trie();//        for(int i=0;i&lt;arr.length;i++)//            trie.insert(arr[i]);//        System.out.println(trie.startsWith(&quot;tr&quot;));//        System.out.println(trie.startsWith(&quot;in&quot;));//        System.out.println(trie.startsWith(&quot;sea&quot;));//        System.out.println(trie.search(&quot;Trie&quot;));//        System.out.println(trie.search(&quot;insert&quot;));//        System.out.println(trie.search(&quot;word&quot;));//    }}/*** Your Trie object will be instantiated and called as such:* Trie obj = new Trie();* obj.insert(word);* boolean param_2 = obj.search(word);* boolean param_3 = obj.startsWith(prefix);*/</code></pre>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Trie </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构--数组</title>
      <link href="/2018/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>/2018/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构--数组</title>
      <link href="/2018/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-BST/"/>
      <url>/2018/12/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-BST/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><pre><code>    public class BST&lt;E extends Comparable&lt;E&gt;&gt; {    private class Node {        public E e;        public Node left, right;        public Node(E e) {            this.e = e;            left = null;            right = null;        }    }    private Node root;    private int size;    public BST(){        root = null;        size = 0;    }    public int size(){        return size;    }    public boolean isEmpty(){        return size == 0;    }    // 向二分搜索树中添加新的元素e    public void add(E e){        if(root == null){            root = new Node(e);            size ++;        }        else            add(root, e);    }    // 向以node为根的二分搜索树中插入元素e，递归算法    private void add(Node node, E e){        if(e.equals(node.e))            return;        else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null){            node.left = new Node(e);            size ++;            return;        }        else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null){            node.right = new Node(e);            size ++;            return;        }        if(e.compareTo(node.e) &lt; 0)            add(node.left, e);        else //e.compareTo(node.e) &gt; 0            add(node.right, e);    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>多线程</title>
      <link href="/2018/12/14/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2018/12/14/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.imgur.com/swmpvzO.jpg" alt="dddddd"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>basic12</title>
      <link href="/2018/12/05/%E8%93%9D%E6%A1%A5%E6%9D%AF-basic12/"/>
      <url>/2018/12/05/%E8%93%9D%E6%A1%A5%E6%9D%AF-basic12/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>123321是一个非常特殊的数，它从左边读和从右边读是一样的。<br>　　输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>　　输入一行，包含一个正整数n。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>　　按从小到大的顺序输出满足条件的整数，每个整数占一行。</p><p>说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。<br>    package algorithm.Lanqiao.基础练习;</p><pre><code>import java.util.Scanner;public class base9 {public static void main(String[] args) {    int n;    Scanner in = new Scanner(System.in);    n = in.nextInt();    in.close();    //5位的    for (int i = 1; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            for (int k = 0; k &lt; 10; k++) {                if (i * 2 + j * 2 + k == n) {                    System.out.print(i);                    System.out.print(j);                    System.out.print(k);                    System.out.print(j);                    System.out.print(i);                    System.out.println();                }            }        }    }    //6位的    for (int i = 1; i &lt; 10; i++) {        for (int j = 0; j &lt; 10; j++) {            for (int k = 0; k &lt; 10; k++) {                if (i * 2 + j * 2 + k * 2 == n) {                    System.out.print(i);                    System.out.print(j);                    System.out.print(k);                    System.out.print(k);                    System.out.print(j);                    System.out.print(i);                    System.out.println();                }            }        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 蓝桥杯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我滴妈</title>
      <link href="/2018/12/05/%E8%93%9D%E6%A1%A5%E8%A2%AB%E5%85%A5%E9%97%A8%E9%A2%98%E7%AC%AC%E4%B8%80%E9%A2%98/"/>
      <url>/2018/12/05/%E8%93%9D%E6%A1%A5%E8%A2%AB%E5%85%A5%E9%97%A8%E9%A2%98%E7%AC%AC%E4%B8%80%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。</p><p>当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。</p><h1 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h1><p>输入包含一个整数n。</p><h1 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h1><p>输出一行，包含一个整数，表示Fn除以10007的余数。</p><p>说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。</p><pre><code>package begin4;import java.util.Scanner;public class Main {    public static void main(String[] args) {        int[] f= new int[1000001];        f[1] = f[2] = 1;        for (int i = 3; i &lt;= 1000000; i++) {            f[i] = (f[i-1] + f[i-2]) % 10007;        }        Scanner in = new Scanner(System.in);        System.out.println(f[in.nextInt()]);        in.close();    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 蓝桥杯 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
