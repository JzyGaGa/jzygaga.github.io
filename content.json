{"meta":{"title":"飞翔的傻瓜","subtitle":"菜鸟的试飞之旅","description":null,"author":"FlyingFool","url":"https://jzygaga.github.io"},"pages":[],"posts":[{"title":"","slug":"剑指offer","date":"2019-01-02T06:19:14.000Z","updated":"2019-01-02T06:20:42.115Z","comments":true,"path":"2019/01/02/剑指offer/","link":"","permalink":"https://jzygaga.github.io/2019/01/02/剑指offer/","excerpt":"","text":"呵呵","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://jzygaga.github.io/categories/剑指offer/"}],"tags":[]},{"title":"反射","slug":"java-反射","date":"2019-01-02T05:34:53.000Z","updated":"2019-01-02T06:16:14.561Z","comments":true,"path":"2019/01/02/java-反射/","link":"","permalink":"https://jzygaga.github.io/2019/01/02/java-反射/","excerpt":"","text":"对方的付费","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://jzygaga.github.io/tags/反射/"}]},{"title":"工厂模式","slug":"设计模式-代理模式","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T05:15:53.836Z","comments":true,"path":"2019/01/01/设计模式-代理模式/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/设计模式-代理模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jzygaga.github.io/categories/设计模式/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://jzygaga.github.io/tags/代理模式/"}]},{"title":"工厂模式","slug":"设计模式-工产模式","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T05:10:24.762Z","comments":true,"path":"2019/01/01/设计模式-工产模式/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/设计模式-工产模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jzygaga.github.io/categories/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://jzygaga.github.io/tags/工厂模式/"}]},{"title":"AVL树","slug":"数据结构-AVL树","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T07:53:15.273Z","comments":true,"path":"2019/01/01/数据结构-AVL树/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/数据结构-AVL树/","excerpt":"","text":"AVL树 平衡二叉树的定义 对于任意一个节点，左子树和右子树的高度差不能超过1 AVL树有着自己的平衡性，所以在自己的增加和删除，不会退化成一个链表 满二叉树 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空 AVL 定义每一个节点的高度 计算平衡因子 定义： 每个节点的平衡因子等于左子树减去右子树的差 作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的 AVL的左旋转右旋转 当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。 package AVLTree; import java.util.ArrayList; public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private class Node{ public K key; public V value; public Node left, right; public int height; public Node(K key, V value){ this.key = key; this.value = value; left = null; right = null; height = 1; } } private Node root; private int size; public AVLTree(){ root = null; size = 0; } public int getSize(){ return size; } public boolean isEmpty(){ return size == 0; } // 获得节点node的高度 private int getHeight(Node node){ if(node == null) return 0; return node.height; } // 获得节点node的平衡因子 private int getBalanceFactor(Node node){ if(node == null) return 0; return getHeight(node.left) - getHeight(node.right); } // 向二分搜索树中添加新的元素(key, value) public void add(K key, V value){ root = add(root, key, value); } // 向以node为根的二分搜索树中插入元素(key, value)，递归算法 // 返回插入新节点后二分搜索树的根 private Node add(Node node, K key, V value){ if(node == null){ size ++; return new Node(key, value); } if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // 更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0) return rightRotate(node); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0) return leftRotate(node); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) { //先进行左旋 node.left= leftRotate(node.left); return rightRotate(node); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) { node.right=rightRotate(node.right); return leftRotate(node); } return node; } //对节点进行左旋操作，返回旋转后的新节点X // y x // / \\ / \\ // T1 x 向右旋转(y),左侧过高不平衡 y z // / \\ ----------------------&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T4 T3 // private Node leftRotate(Node y) { Node x=y.right; Node T2=x.right; //向右旋转过程 x.left=y; y.right=T2; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } //对节点进行右旋操作，返回旋转后的新节点X // y x // / \\ / \\ // x T4 向右旋转(y),左侧过高不平衡 z y // / \\ ----------------------&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 // 返回以node为根节点的二分搜索树中，key所在的节点 private Node rightRotate(Node y) { Node x=y.left; Node T3=x.right; //向右旋转过程 x.right=y; y.left=T3; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } private Node getNode(Node node, K key){ if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); } public boolean contains(K key){ return getNode(root, key) != null; } public V get(K key){ Node node = getNode(root, key); return node == null ? null : node.value; } public void set(K key, V newValue){ Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;); node.value = newValue; } // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node){ if(node.left == null) return node; return minimum(node.left); } // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node){ if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } node.left = removeMin(node.left); return node; } // 从二分搜索树中删除键为key的节点 public V remove(K key){ Node node = getNode(root, key); if(node != null){ root = remove(root, key); return node.value; } return null; } private Node remove(Node node, K key){ if( node == null ) return null; Node retNode; if( key.compareTo(node.key) &lt; 0 ){ node.left = remove(node.left , key); retNode= node; } else if(key.compareTo(node.key) &gt; 0 ){ node.right = remove(node.right, key); retNode= node; } else{ // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null){ Node rightNode = node.right; node.right = null; size --; retNode= rightNode; }else if(node.right == null){ // 待删除节点右子树为空的情况 Node leftNode = node.left; node.left = null; size --; retNode= leftNode; }else { // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = remove(node.right,successor.key); successor.left = node.left; node.left = node.right = null; retNode= successor; } } if(retNode==null) return retNode; // 更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); int balanceFactor = getBalanceFactor(retNode); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0) return rightRotate(retNode); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0) return leftRotate(retNode); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) { //先进行左旋 node.left= leftRotate(retNode.left); return rightRotate(retNode); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) { retNode.right=rightRotate(retNode.right); return leftRotate(retNode); } return retNode; } public static void main(String[] args){ System.out.println(&quot;Pride and Prejudice&quot;); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) { System.out.println(&quot;Total words: &quot; + words.size()); AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;(); for (String word : words) { if (map.contains(word)) map.set(word, map.get(word) + 1); else map.add(word, 1); } System.out.println(&quot;Total different words: &quot; + map.getSize()); System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;)); System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;)); System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST()); System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced()); for(String word:words) { map.remove(word); if(!map.isBalanced()||!map.isBST()) { throw new RuntimeException(&quot;error！&quot;); } } } System.out.println(); } public boolean isBST() { //BST在中序边遍历是从小到大来的 ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;(); inOrder(root,keys); for(int i=1;i&lt;keys.size();i++) //注意i-1 if(keys.get(i-1).compareTo(keys.get(i))&gt;0) return false; return true; } private void inOrder(Node root, ArrayList&lt;K&gt; keys) { if(root==null) return ; inOrder(root.left, keys); keys.add(root.key); inOrder(root.right, keys); } //判断二叉树是否是一颗平衡二叉树 public boolean isBalanced() { return isBalanced(root); } //判断以Node为根的二叉树是平衡二叉树，递归算法 public boolean isBalanced(Node node) { if(node==null) return true; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor)&gt;1) return false; return isBalanced(node.left)&amp;&amp;isBalanced(node.right); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"AVL树","slug":"AVL树","permalink":"https://jzygaga.github.io/tags/AVL树/"}]},{"title":"红黑树","slug":"数据结构-红黑树","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T07:48:33.848Z","comments":true,"path":"2019/01/01/数据结构-红黑树/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/数据结构-红黑树/","excerpt":"","text":"红黑树 红黑树定义 算法导论的定义 满二叉树 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空 AVL 定义每一个节点的高度 计算平衡因子 定义： 每个节点的平衡因子等于左子树减去右子树的差 作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的 AVL的左旋转右旋转 当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。 package AVLTree; import java.util.ArrayList; public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private class Node{ public K key; public V value; public Node left, right; public int height; public Node(K key, V value){ this.key = key; this.value = value; left = null; right = null; height = 1; } } private Node root; private int size; public AVLTree(){ root = null; size = 0; } public int getSize(){ return size; } public boolean isEmpty(){ return size == 0; } // 获得节点node的高度 private int getHeight(Node node){ if(node == null) return 0; return node.height; } // 获得节点node的平衡因子 private int getBalanceFactor(Node node){ if(node == null) return 0; return getHeight(node.left) - getHeight(node.right); } // 向二分搜索树中添加新的元素(key, value) public void add(K key, V value){ root = add(root, key, value); } // 向以node为根的二分搜索树中插入元素(key, value)，递归算法 // 返回插入新节点后二分搜索树的根 private Node add(Node node, K key, V value){ if(node == null){ size ++; return new Node(key, value); } if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // 更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0) return rightRotate(node); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0) return leftRotate(node); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) { //先进行左旋 node.left= leftRotate(node.left); return rightRotate(node); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) { node.right=rightRotate(node.right); return leftRotate(node); } return node; } //对节点进行左旋操作，返回旋转后的新节点X // y x // / \\ / \\ // T1 x 向右旋转(y),左侧过高不平衡 y z // / \\ ----------------------&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T4 T3 // private Node leftRotate(Node y) { Node x=y.right; Node T2=x.right; //向右旋转过程 x.left=y; y.right=T2; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } //对节点进行右旋操作，返回旋转后的新节点X // y x // / \\ / \\ // x T4 向右旋转(y),左侧过高不平衡 z y // / \\ ----------------------&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 // 返回以node为根节点的二分搜索树中，key所在的节点 private Node rightRotate(Node y) { Node x=y.left; Node T3=x.right; //向右旋转过程 x.right=y; y.left=T3; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } private Node getNode(Node node, K key){ if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); } public boolean contains(K key){ return getNode(root, key) != null; } public V get(K key){ Node node = getNode(root, key); return node == null ? null : node.value; } public void set(K key, V newValue){ Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;); node.value = newValue; } // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node){ if(node.left == null) return node; return minimum(node.left); } // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node){ if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } node.left = removeMin(node.left); return node; } // 从二分搜索树中删除键为key的节点 public V remove(K key){ Node node = getNode(root, key); if(node != null){ root = remove(root, key); return node.value; } return null; } private Node remove(Node node, K key){ if( node == null ) return null; Node retNode; if( key.compareTo(node.key) &lt; 0 ){ node.left = remove(node.left , key); retNode= node; } else if(key.compareTo(node.key) &gt; 0 ){ node.right = remove(node.right, key); retNode= node; } else{ // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null){ Node rightNode = node.right; node.right = null; size --; retNode= rightNode; }else if(node.right == null){ // 待删除节点右子树为空的情况 Node leftNode = node.left; node.left = null; size --; retNode= leftNode; }else { // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = remove(node.right,successor.key); successor.left = node.left; node.left = node.right = null; retNode= successor; } } if(retNode==null) return retNode; // 更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); int balanceFactor = getBalanceFactor(retNode); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0) return rightRotate(retNode); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0) return leftRotate(retNode); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) { //先进行左旋 node.left= leftRotate(retNode.left); return rightRotate(retNode); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) { retNode.right=rightRotate(retNode.right); return leftRotate(retNode); } return retNode; } public static void main(String[] args){ System.out.println(&quot;Pride and Prejudice&quot;); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) { System.out.println(&quot;Total words: &quot; + words.size()); AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;(); for (String word : words) { if (map.contains(word)) map.set(word, map.get(word) + 1); else map.add(word, 1); } System.out.println(&quot;Total different words: &quot; + map.getSize()); System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;)); System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;)); System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST()); System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced()); for(String word:words) { map.remove(word); if(!map.isBalanced()||!map.isBST()) { throw new RuntimeException(&quot;error！&quot;); } } } System.out.println(); } public boolean isBST() { //BST在中序边遍历是从小到大来的 ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;(); inOrder(root,keys); for(int i=1;i&lt;keys.size();i++) //注意i-1 if(keys.get(i-1).compareTo(keys.get(i))&gt;0) return false; return true; } private void inOrder(Node root, ArrayList&lt;K&gt; keys) { if(root==null) return ; inOrder(root.left, keys); keys.add(root.key); inOrder(root.right, keys); } //判断二叉树是否是一颗平衡二叉树 public boolean isBalanced() { return isBalanced(root); } //判断以Node为根的二叉树是平衡二叉树，递归算法 public boolean isBalanced(Node node) { if(node==null) return true; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor)&gt;1) return false; return isBalanced(node.left)&amp;&amp;isBalanced(node.right); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"https://jzygaga.github.io/tags/红黑树/"}]},{"title":"计算机网络基础","slug":"计算机网络","date":"2019-01-01T09:27:13.000Z","updated":"2019-01-02T06:24:02.162Z","comments":true,"path":"2019/01/01/计算机网络/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/计算机网络/","excerpt":"","text":"计算机网络的分层 应用层：数据服务那个协议。 传输层：解决出错重传机制， 网络层： 数据链路层： 物理层：不可靠，不安全。发展时代：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层， 不可靠，不安全。对数据的检验，数据服务那个协议，出错重传，应用协议。 网络传输的不可靠 丢包，重复包 出错 乱序滑动窗口 问题提出 改进方案 功能 增加吞吐量，提高效率。 一直等5的ack接受信号，整个接受5ack信号，接受到5返回整个接受ack信息。比如，未接受到5的ack信息，即使接收到6，7，8，9，10，11也不会发送ack信息 wireshark Src：IntelCor电脑 Dst:到路由器 链路层 Src:本机的ip地址 Dst:DNS服务器","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jzygaga.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jzygaga.github.io/tags/计算机网络/"}]},{"title":"哈希表","slug":"数据结构-哈希表","date":"2018-12-30T06:57:43.000Z","updated":"2019-01-02T07:48:35.645Z","comments":true,"path":"2018/12/30/数据结构-哈希表/","link":"","permalink":"https://jzygaga.github.io/2018/12/30/数据结构-哈希表/","excerpt":"","text":"哈希表导学例子：387. First Unique Character in a StringGiven a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples: s = &quot;leetcode&quot; return 0. s = &quot;loveleetcode&quot;, return 2. 代码 class Solution { public int firstUniqChar(String s) { int[] arr=new int[26]; for(int i=0;i&lt;s.length();i++){ arr[s.charAt(i)-&apos;a&apos;]++; } for(int i=0;i&lt;s.length();i++){ if(arr[s.charAt(i)-&apos;a&apos;]==1) return i; } return -1; } } 什么是哈希表 对于我们所关注的内容，比如例子中的字符串，我们建立字符串与我们想要得到值之间的索引的数据结构，我们称之为哈希表。 对于转换的过程我们称之为哈希函数。f(ch)=ch-‘a’; 哈希函数就是把’键’转换成’索引’，如果不同的健对应相同值称之为哈希冲突。 学习哈希表主要解决的问题： 把键转换成索引 解决哈希冲突 哈希表充分体现了算法设计思想：空间换时间。 通过健得到索引分越均匀越好。 哈希函数的设计 对于整型 小范围的正整数正常使用 小范围的负整数进行偏移 -100~100-0~200 大整数 比如身份证号码110108198512166666 选择模一个素数。 浮点型转换成整型 字符串 转成整型处理 166 1100+610+6*1 code c26^3+o26^2+d26^1+e26^0; hash(code)=(cB^3+oB^2+dB^1+eB^0)%M; 设计哈希函数的原则： 一致性：如果a==b,则hash(a)==hash(b) 高效性：计算高校便捷 均匀性：哈希值均匀分布 java中的hashcodepackage Hashtable; public class Student { private int grade; private int cls; private String firstName; private String lastName; public Student(int grade, int cls, String firstName, String lastName) { this.grade = grade; this.cls = cls; this.firstName = firstName; this.lastName = lastName; } @Override public int hashCode() { int B=31; int hash=0; hash=hash*B+grade; hash=hash*B+cls; //不区分大小写。。 hash=hash*B+firstName.hashCode(); hash=hash*B+lastName.hashCode(); return hash; } } java中解决hashcode的方法 Seperate Chaining (hashCode(k1)&amp;0x7fffffff)%M 根据hash值就算出索引 如果产生冲突了，就在后面添加一个，就相当于每个索引后面接一个链表，但是我们为了优化访问的速度，可以接一个红黑树。 k2-&gt;k3相当于一个查找表。所以hashMap就相当于treemap的数组，HashSet相当于treeSet数组。 在java8之前每一个位置对应一个链表，java8之后一开始一个位置对应一个链表，当哈希冲突达到一定程度每一个位置从链表变成红黑树，在数量小的时候红黑树会进行反转等操作。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"https://jzygaga.github.io/tags/哈希表/"}]},{"title":"lamda","slug":"java-lamda","date":"2018-12-29T09:07:54.000Z","updated":"2019-01-01T12:33:44.722Z","comments":true,"path":"2018/12/29/java-lamda/","link":"","permalink":"https://jzygaga.github.io/2018/12/29/java-lamda/","excerpt":"","text":"JAVA8新特性——Lamda表达式Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。 先来看看传统的匿名内部类调用方式: interface MyInterface{ void lMethod(); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(); } public static void main(String[] args) { test(new MyInterface() { @Override public void lMethod() { System.out.println(&quot;Hello World!&quot;); } }); } } 在主类中的这么几行代码，嵌套几层就为了输出一个Hello World！是不是很麻烦？但是由于java结构的完整性，我们还不得不那么做，现在JDK1.8来了。 再来看看使用Lamda表达式改写上面的代码： interface Myinterface{ void IMethod(); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(); } public static void main(String[] args) { test(()-&gt; System.out.println(&quot;666&quot;)); } } 这就是Lamda表达式语言，为了解决匿名内部类繁杂的操作而出现。 Lamda语法有三种形式： (参数) -&gt;单行语句； (参数) -&gt;{多行语句}； (参数) -&gt;表达式；括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&gt;System.out.println(“Hello World!”) 前面的()代表void lMethod()方法，它没有入参，所以为空，-&gt;后面是一个单行语句；如果-&gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;-&gt;后面也可以是一个表达式，如：a+b等。 (参数) -&gt;单行语句； interface MyInterface{ void lMethod(String str); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(&quot;Hello World!&quot;);//设置参数内容 } public static void main(String[] args) { //首先在()中定义此表达式里面需要接收变量s，后面的单行语句中就可以使用该变量了 test((s)-&gt;System.out.println(s)); } } (参数) -&gt;多行语句； interface Myinterface{ void IMethod(String str); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(&quot;hello word&quot;); } public static void main(String[] args) { test((s)-&gt; { s=s+s; System.out.println(s); }); } } 这样，Lamda表达式就看起来很简单了，有不有！ 匿名内部类，我们比较常用的地方在哪儿？线程类Thread，以前我们可能这样写： 总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"lamda","slug":"lamda","permalink":"https://jzygaga.github.io/tags/lamda/"}]},{"title":"并查集","slug":"数据结构-并查集","date":"2018-12-22T03:44:56.000Z","updated":"2019-01-02T07:44:40.976Z","comments":true,"path":"2018/12/22/数据结构-并查集/","link":"","permalink":"https://jzygaga.github.io/2018/12/22/数据结构-并查集/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://jzygaga.github.io/tags/并查集/"}]},{"title":"leetcode","slug":"leetcode-211. Add and Search Word - Data structure design","date":"2018-12-20T11:36:27.000Z","updated":"2019-01-02T06:09:38.223Z","comments":true,"path":"2018/12/20/leetcode-211. Add and Search Word - Data structure design/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/leetcode-211. Add and Search Word - Data structure design/","excerpt":"","text":"211. Add and Search Word - Data structure design Design a data structure that supports the following two operations: 描述addWord(&quot;bad&quot;) addWord(&quot;dad&quot;) addWord(&quot;mad&quot;) search(&quot;pad&quot;) -&gt; false search(&quot;bad&quot;) -&gt; true search(&quot;.ad&quot;) -&gt; true search(&quot;b..&quot;) -&gt; true 代码class WordDictionary { private class Node{ public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) { this.isWord=isWord; next=new TreeMap&lt;&gt;(); } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public WordDictionary() { root=new Node(); size=0; } /** Adds a word into the data structure. */ public void addWord(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { cur.next.put(c, new Node()); } cur=cur.next.get(c); } cur.isWord=true; size++; } /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */ public boolean search(String word) { int i=0; Node cur=root; return recurtionSearch(i,word,cur); } private boolean recurtionSearch(int i,String str,Node cur) { if(i==str.length()) return cur.isWord; char m=str.charAt(i); if(m!=&apos;.&apos;) { if(cur.next.get(m)==null) return false; return recurtionSearch(++i, str,cur.next.get(m)); }else { //这个逻辑，就跳过点.这个位置 for(char c:cur.next.keySet()) if(recurtionSearch(++i, str,cur.next.get(c))) return true; return false; } } // public static void main(String[] args) { // WordDictionary wordDictionary = new WordDictionary(); // wordDictionary.addWord(&quot;123&quot;); // ; // System.out.println(wordDictionary.search(&quot;.3&quot;)); // } } /** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"https://jzygaga.github.io/tags/Trie/"}]},{"title":"leetcode","slug":"leetcode-208. Implement Trie (Prefix Tree) - 副本","date":"2018-12-20T11:36:27.000Z","updated":"2019-01-02T05:33:20.270Z","comments":true,"path":"2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","excerpt":"","text":"208. Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. 描述Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // returns truetrie.search(“app”); // returns falsetrie.startsWith(“app”); // returns truetrie.insert(“app”);trie.search(“app”); // returns true * 代码class Trie { private class Node { public boolean isWord; public TreeMap&lt;Character, Node&gt; next; public Node(boolean isWord) { next = new TreeMap&lt;&gt;(); this.isWord = isWord; } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public Trie() { root=new Node(); size=0; } /** Inserts a word into the trie. */ public void insert(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); Node node = cur.next.get(c); if(node==null) cur.next.put(c, new Node()); cur=cur.next.get(c); } cur.isWord=true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return cur.isWord; } /** * Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Node cur=root; for(int i=0;i&lt;prefix.length();i++) { char c = prefix.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return true; } // public static void main(String[] args) { // String[] arr= {&quot;Trie&quot;,&quot;insert&quot;,&quot;search&quot;,&quot;startWith&quot;,&quot;insert&quot;,&quot;search&quot;}; // Trie trie = new Trie(); // for(int i=0;i&lt;arr.length;i++) // trie.insert(arr[i]); // System.out.println(trie.startsWith(&quot;tr&quot;)); // System.out.println(trie.startsWith(&quot;in&quot;)); // System.out.println(trie.startsWith(&quot;sea&quot;)); // System.out.println(trie.search(&quot;Trie&quot;)); // System.out.println(trie.search(&quot;insert&quot;)); // System.out.println(trie.search(&quot;word&quot;)); // } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"https://jzygaga.github.io/tags/Trie/"}]},{"title":"数据结构--数组","slug":"数据结构-BST","date":"2018-12-14T15:16:31.000Z","updated":"2018-12-18T13:56:30.773Z","comments":true,"path":"2018/12/14/数据结构-BST/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-BST/","excerpt":"","text":"二叉搜索树 public class BST&lt;E extends Comparable&lt;E&gt;&gt; { private class Node { public E e; public Node left, right; public Node(E e) { this.e = e; left = null; right = null; } } private Node root; private int size; public BST(){ root = null; size = 0; } public int size(){ return size; } public boolean isEmpty(){ return size == 0; } // 向二分搜索树中添加新的元素e public void add(E e){ if(root == null){ root = new Node(e); size ++; } else add(root, e); } // 向以node为根的二分搜索树中插入元素e，递归算法 private void add(Node node, E e){ if(e.equals(node.e)) return; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null){ node.left = new Node(e); size ++; return; } else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null){ node.right = new Node(e); size ++; return; } if(e.compareTo(node.e) &lt; 0) add(node.left, e); else //e.compareTo(node.e) &gt; 0 add(node.right, e); } }","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"数据结构--数组","slug":"数据结构-栈","date":"2018-12-14T15:16:31.000Z","updated":"2018-12-14T15:17:28.698Z","comments":true,"path":"2018/12/14/数据结构-栈/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-栈/","excerpt":"","text":"","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"多线程","slug":"java-多线程","date":"2018-12-14T05:53:05.000Z","updated":"2019-01-02T06:23:32.010Z","comments":true,"path":"2018/12/14/java-多线程/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/java-多线程/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://jzygaga.github.io/tags/多线程/"}]},{"title":"basic12","slug":"蓝桥杯-basic12","date":"2018-12-05T06:01:18.000Z","updated":"2019-01-02T06:28:58.388Z","comments":true,"path":"2018/12/05/蓝桥杯-basic12/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/蓝桥杯-basic12/","excerpt":"","text":"问题描述123321是一个非常特殊的数，它从左边读和从右边读是一样的。 输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 输入格式 输入一行，包含一个正整数n。 输出格式 按从小到大的顺序输出满足条件的整数，每个整数占一行。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package algorithm.Lanqiao.基础练习; import java.util.Scanner; public class base9 { public static void main(String[] args) { int n; Scanner in = new Scanner(System.in); n = in.nextInt(); in.close(); //5位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } //6位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k * 2 == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } }","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/categories/蓝桥杯/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]},{"title":"我滴妈","slug":"蓝桥被入门题第一题","date":"2018-12-05T06:01:18.000Z","updated":"2018-12-08T16:08:25.969Z","comments":true,"path":"2018/12/05/蓝桥被入门题第一题/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/蓝桥被入门题第一题/","excerpt":"","text":"问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package begin4; import java.util.Scanner; public class Main { public static void main(String[] args) { int[] f= new int[1000001]; f[1] = f[2] = 1; for (int i = 3; i &lt;= 1000000; i++) { f[i] = (f[i-1] + f[i-2]) % 10007; } Scanner in = new Scanner(System.in); System.out.println(f[in.nextInt()]); in.close(); } }","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]}]}