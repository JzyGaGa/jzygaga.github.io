{"meta":{"title":"飞翔的傻瓜","subtitle":"菜鸟的试飞之旅","description":null,"author":"FlyingFool","url":"https://jzygaga.github.io"},"pages":[],"posts":[{"title":"准备编辑的博客","slug":"准备编辑的博客","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T05:04:56.338Z","comments":true,"path":"2019/01/01/准备编辑的博客/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/准备编辑的博客/","excerpt":"","text":"红黑树 红黑树定义 算法导论的定义 满二叉树 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空 AVL 定义每一个节点的高度 计算平衡因子 定义： 每个节点的平衡因子等于左子树减去右子树的差 作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的 AVL的左旋转右旋转 当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。 package AVLTree; import java.util.ArrayList; public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private class Node{ public K key; public V value; public Node left, right; public int height; public Node(K key, V value){ this.key = key; this.value = value; left = null; right = null; height = 1; } } private Node root; private int size; public AVLTree(){ root = null; size = 0; } public int getSize(){ return size; } public boolean isEmpty(){ return size == 0; } // 获得节点node的高度 private int getHeight(Node node){ if(node == null) return 0; return node.height; } // 获得节点node的平衡因子 private int getBalanceFactor(Node node){ if(node == null) return 0; return getHeight(node.left) - getHeight(node.right); } // 向二分搜索树中添加新的元素(key, value) public void add(K key, V value){ root = add(root, key, value); } // 向以node为根的二分搜索树中插入元素(key, value)，递归算法 // 返回插入新节点后二分搜索树的根 private Node add(Node node, K key, V value){ if(node == null){ size ++; return new Node(key, value); } if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // 更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0) return rightRotate(node); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0) return leftRotate(node); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) { //先进行左旋 node.left= leftRotate(node.left); return rightRotate(node); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) { node.right=rightRotate(node.right); return leftRotate(node); } return node; } //对节点进行左旋操作，返回旋转后的新节点X // y x // / \\ / \\ // T1 x 向右旋转(y),左侧过高不平衡 y z // / \\ ----------------------&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T4 T3 // private Node leftRotate(Node y) { Node x=y.right; Node T2=x.right; //向右旋转过程 x.left=y; y.right=T2; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } //对节点进行右旋操作，返回旋转后的新节点X // y x // / \\ / \\ // x T4 向右旋转(y),左侧过高不平衡 z y // / \\ ----------------------&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 // 返回以node为根节点的二分搜索树中，key所在的节点 private Node rightRotate(Node y) { Node x=y.left; Node T3=x.right; //向右旋转过程 x.right=y; y.left=T3; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } private Node getNode(Node node, K key){ if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); } public boolean contains(K key){ return getNode(root, key) != null; } public V get(K key){ Node node = getNode(root, key); return node == null ? null : node.value; } public void set(K key, V newValue){ Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;); node.value = newValue; } // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node){ if(node.left == null) return node; return minimum(node.left); } // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node){ if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } node.left = removeMin(node.left); return node; } // 从二分搜索树中删除键为key的节点 public V remove(K key){ Node node = getNode(root, key); if(node != null){ root = remove(root, key); return node.value; } return null; } private Node remove(Node node, K key){ if( node == null ) return null; Node retNode; if( key.compareTo(node.key) &lt; 0 ){ node.left = remove(node.left , key); retNode= node; } else if(key.compareTo(node.key) &gt; 0 ){ node.right = remove(node.right, key); retNode= node; } else{ // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null){ Node rightNode = node.right; node.right = null; size --; retNode= rightNode; }else if(node.right == null){ // 待删除节点右子树为空的情况 Node leftNode = node.left; node.left = null; size --; retNode= leftNode; }else { // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = remove(node.right,successor.key); successor.left = node.left; node.left = node.right = null; retNode= successor; } } if(retNode==null) return retNode; // 更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); int balanceFactor = getBalanceFactor(retNode); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0) return rightRotate(retNode); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0) return leftRotate(retNode); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) { //先进行左旋 node.left= leftRotate(retNode.left); return rightRotate(retNode); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) { retNode.right=rightRotate(retNode.right); return leftRotate(retNode); } return retNode; } public static void main(String[] args){ System.out.println(&quot;Pride and Prejudice&quot;); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) { System.out.println(&quot;Total words: &quot; + words.size()); AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;(); for (String word : words) { if (map.contains(word)) map.set(word, map.get(word) + 1); else map.add(word, 1); } System.out.println(&quot;Total different words: &quot; + map.getSize()); System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;)); System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;)); System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST()); System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced()); for(String word:words) { map.remove(word); if(!map.isBalanced()||!map.isBST()) { throw new RuntimeException(&quot;error！&quot;); } } } System.out.println(); } public boolean isBST() { //BST在中序边遍历是从小到大来的 ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;(); inOrder(root,keys); for(int i=1;i&lt;keys.size();i++) //注意i-1 if(keys.get(i-1).compareTo(keys.get(i))&gt;0) return false; return true; } private void inOrder(Node root, ArrayList&lt;K&gt; keys) { if(root==null) return ; inOrder(root.left, keys); keys.add(root.key); inOrder(root.right, keys); } //判断二叉树是否是一颗平衡二叉树 public boolean isBalanced() { return isBalanced(root); } //判断以Node为根的二叉树是平衡二叉树，递归算法 public boolean isBalanced(Node node) { if(node==null) return true; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor)&gt;1) return false; return isBalanced(node.left)&amp;&amp;isBalanced(node.right); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"https://jzygaga.github.io/tags/红黑树/"}]},{"title":"lamda","slug":"lamda","date":"2018-12-29T09:07:54.000Z","updated":"2019-01-01T12:33:44.722Z","comments":true,"path":"2018/12/29/lamda/","link":"","permalink":"https://jzygaga.github.io/2018/12/29/lamda/","excerpt":"","text":"JAVA8新特性——Lamda表达式Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。 先来看看传统的匿名内部类调用方式: interface MyInterface{ void lMethod(); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(); } public static void main(String[] args) { test(new MyInterface() { @Override public void lMethod() { System.out.println(&quot;Hello World!&quot;); } }); } } 在主类中的这么几行代码，嵌套几层就为了输出一个Hello World！是不是很麻烦？但是由于java结构的完整性，我们还不得不那么做，现在JDK1.8来了。 再来看看使用Lamda表达式改写上面的代码： interface Myinterface{ void IMethod(); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(); } public static void main(String[] args) { test(()-&gt; System.out.println(&quot;666&quot;)); } } 这就是Lamda表达式语言，为了解决匿名内部类繁杂的操作而出现。 Lamda语法有三种形式： (参数) -&gt;单行语句； (参数) -&gt;{多行语句}； (参数) -&gt;表达式；括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&gt;System.out.println(“Hello World!”) 前面的()代表void lMethod()方法，它没有入参，所以为空，-&gt;后面是一个单行语句；如果-&gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;-&gt;后面也可以是一个表达式，如：a+b等。 (参数) -&gt;单行语句； interface MyInterface{ void lMethod(String str); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(&quot;Hello World!&quot;);//设置参数内容 } public static void main(String[] args) { //首先在()中定义此表达式里面需要接收变量s，后面的单行语句中就可以使用该变量了 test((s)-&gt;System.out.println(s)); } } (参数) -&gt;多行语句； interface Myinterface{ void IMethod(String str); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(&quot;hello word&quot;); } public static void main(String[] args) { test((s)-&gt; { s=s+s; System.out.println(s); }); } } 这样，Lamda表达式就看起来很简单了，有不有！ 匿名内部类，我们比较常用的地方在哪儿？线程类Thread，以前我们可能这样写： 总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"lamda","slug":"lamda","permalink":"https://jzygaga.github.io/tags/lamda/"}]},{"title":"AVL树","slug":"数据结构-AVL树","date":"2018-12-22T03:44:56.000Z","updated":"2019-01-01T12:53:33.407Z","comments":true,"path":"2018/12/22/数据结构-AVL树/","link":"","permalink":"https://jzygaga.github.io/2018/12/22/数据结构-AVL树/","excerpt":"","text":"AVL树 平衡二叉树的定义 对于任意一个节点，左子树和右子树的高度差不能超过1 AVL树有着自己的平衡性，所以在自己的增加和删除，不会退化成一个链表 满二叉树 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空 AVL 定义每一个节点的高度 计算平衡因子 定义： 每个节点的平衡因子等于左子树减去右子树的差 作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的 AVL的左旋转右旋转 当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。 package AVLTree; import java.util.ArrayList; public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private class Node{ public K key; public V value; public Node left, right; public int height; public Node(K key, V value){ this.key = key; this.value = value; left = null; right = null; height = 1; } } private Node root; private int size; public AVLTree(){ root = null; size = 0; } public int getSize(){ return size; } public boolean isEmpty(){ return size == 0; } // 获得节点node的高度 private int getHeight(Node node){ if(node == null) return 0; return node.height; } // 获得节点node的平衡因子 private int getBalanceFactor(Node node){ if(node == null) return 0; return getHeight(node.left) - getHeight(node.right); } // 向二分搜索树中添加新的元素(key, value) public void add(K key, V value){ root = add(root, key, value); } // 向以node为根的二分搜索树中插入元素(key, value)，递归算法 // 返回插入新节点后二分搜索树的根 private Node add(Node node, K key, V value){ if(node == null){ size ++; return new Node(key, value); } if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // 更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0) return rightRotate(node); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0) return leftRotate(node); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) { //先进行左旋 node.left= leftRotate(node.left); return rightRotate(node); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) { node.right=rightRotate(node.right); return leftRotate(node); } return node; } //对节点进行左旋操作，返回旋转后的新节点X // y x // / \\ / \\ // T1 x 向右旋转(y),左侧过高不平衡 y z // / \\ ----------------------&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T4 T3 // private Node leftRotate(Node y) { Node x=y.right; Node T2=x.right; //向右旋转过程 x.left=y; y.right=T2; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } //对节点进行右旋操作，返回旋转后的新节点X // y x // / \\ / \\ // x T4 向右旋转(y),左侧过高不平衡 z y // / \\ ----------------------&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 // 返回以node为根节点的二分搜索树中，key所在的节点 private Node rightRotate(Node y) { Node x=y.left; Node T3=x.right; //向右旋转过程 x.right=y; y.left=T3; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } private Node getNode(Node node, K key){ if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); } public boolean contains(K key){ return getNode(root, key) != null; } public V get(K key){ Node node = getNode(root, key); return node == null ? null : node.value; } public void set(K key, V newValue){ Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;); node.value = newValue; } // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node){ if(node.left == null) return node; return minimum(node.left); } // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node){ if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } node.left = removeMin(node.left); return node; } // 从二分搜索树中删除键为key的节点 public V remove(K key){ Node node = getNode(root, key); if(node != null){ root = remove(root, key); return node.value; } return null; } private Node remove(Node node, K key){ if( node == null ) return null; Node retNode; if( key.compareTo(node.key) &lt; 0 ){ node.left = remove(node.left , key); retNode= node; } else if(key.compareTo(node.key) &gt; 0 ){ node.right = remove(node.right, key); retNode= node; } else{ // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null){ Node rightNode = node.right; node.right = null; size --; retNode= rightNode; }else if(node.right == null){ // 待删除节点右子树为空的情况 Node leftNode = node.left; node.left = null; size --; retNode= leftNode; }else { // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = remove(node.right,successor.key); successor.left = node.left; node.left = node.right = null; retNode= successor; } } if(retNode==null) return retNode; // 更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); int balanceFactor = getBalanceFactor(retNode); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0) return rightRotate(retNode); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0) return leftRotate(retNode); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) { //先进行左旋 node.left= leftRotate(retNode.left); return rightRotate(retNode); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) { retNode.right=rightRotate(retNode.right); return leftRotate(retNode); } return retNode; } public static void main(String[] args){ System.out.println(&quot;Pride and Prejudice&quot;); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) { System.out.println(&quot;Total words: &quot; + words.size()); AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;(); for (String word : words) { if (map.contains(word)) map.set(word, map.get(word) + 1); else map.add(word, 1); } System.out.println(&quot;Total different words: &quot; + map.getSize()); System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;)); System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;)); System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST()); System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced()); for(String word:words) { map.remove(word); if(!map.isBalanced()||!map.isBST()) { throw new RuntimeException(&quot;error！&quot;); } } } System.out.println(); } public boolean isBST() { //BST在中序边遍历是从小到大来的 ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;(); inOrder(root,keys); for(int i=1;i&lt;keys.size();i++) //注意i-1 if(keys.get(i-1).compareTo(keys.get(i))&gt;0) return false; return true; } private void inOrder(Node root, ArrayList&lt;K&gt; keys) { if(root==null) return ; inOrder(root.left, keys); keys.add(root.key); inOrder(root.right, keys); } //判断二叉树是否是一颗平衡二叉树 public boolean isBalanced() { return isBalanced(root); } //判断以Node为根的二叉树是平衡二叉树，递归算法 public boolean isBalanced(Node node) { if(node==null) return true; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor)&gt;1) return false; return isBalanced(node.left)&amp;&amp;isBalanced(node.right); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"AVL树","slug":"AVL树","permalink":"https://jzygaga.github.io/tags/AVL树/"}]},{"title":"leetcode","slug":"211. Add and Search Word - Data structure design","date":"2018-12-20T11:36:27.000Z","updated":"2018-12-20T13:33:33.752Z","comments":true,"path":"2018/12/20/211. Add and Search Word - Data structure design/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/211. Add and Search Word - Data structure design/","excerpt":"","text":"211. Add and Search Word - Data structure design Design a data structure that supports the following two operations: 描述addWord(&quot;bad&quot;) addWord(&quot;dad&quot;) addWord(&quot;mad&quot;) search(&quot;pad&quot;) -&gt; false search(&quot;bad&quot;) -&gt; true search(&quot;.ad&quot;) -&gt; true search(&quot;b..&quot;) -&gt; true 代码class WordDictionary { private class Node{ public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) { this.isWord=isWord; next=new TreeMap&lt;&gt;(); } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public WordDictionary() { root=new Node(); size=0; } /** Adds a word into the data structure. */ public void addWord(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { cur.next.put(c, new Node()); } cur=cur.next.get(c); } cur.isWord=true; size++; } /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */ public boolean search(String word) { int i=0; Node cur=root; return recurtionSearch(i,word,cur); } private boolean recurtionSearch(int i,String str,Node cur) { if(i==str.length()) return cur.isWord; char m=str.charAt(i); if(m!=&apos;.&apos;) { if(cur.next.get(m)==null) return false; return recurtionSearch(++i, str,cur.next.get(m)); }else { //这个逻辑，就跳过点.这个位置 for(char c:cur.next.keySet()) if(recurtionSearch(++i, str,cur.next.get(c))) return true; return false; } } // public static void main(String[] args) { // WordDictionary wordDictionary = new WordDictionary(); // wordDictionary.addWord(&quot;123&quot;); // ; // System.out.println(wordDictionary.search(&quot;.3&quot;)); // } } /** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */","categories":[],"tags":[{"name":"leetcode Trie","slug":"leetcode-Trie","permalink":"https://jzygaga.github.io/tags/leetcode-Trie/"}]},{"title":"leetcode","slug":"leetcode-208. Implement Trie (Prefix Tree) - 副本","date":"2018-12-20T11:36:27.000Z","updated":"2018-12-20T12:00:03.675Z","comments":true,"path":"2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","excerpt":"","text":"208. Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. 描述Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // returns truetrie.search(“app”); // returns falsetrie.startsWith(“app”); // returns truetrie.insert(“app”);trie.search(“app”); // returns true * 代码class Trie { private class Node { public boolean isWord; public TreeMap&lt;Character, Node&gt; next; public Node(boolean isWord) { next = new TreeMap&lt;&gt;(); this.isWord = isWord; } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public Trie() { root=new Node(); size=0; } /** Inserts a word into the trie. */ public void insert(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); Node node = cur.next.get(c); if(node==null) cur.next.put(c, new Node()); cur=cur.next.get(c); } cur.isWord=true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return cur.isWord; } /** * Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Node cur=root; for(int i=0;i&lt;prefix.length();i++) { char c = prefix.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return true; } // public static void main(String[] args) { // String[] arr= {&quot;Trie&quot;,&quot;insert&quot;,&quot;search&quot;,&quot;startWith&quot;,&quot;insert&quot;,&quot;search&quot;}; // Trie trie = new Trie(); // for(int i=0;i&lt;arr.length;i++) // trie.insert(arr[i]); // System.out.println(trie.startsWith(&quot;tr&quot;)); // System.out.println(trie.startsWith(&quot;in&quot;)); // System.out.println(trie.startsWith(&quot;sea&quot;)); // System.out.println(trie.search(&quot;Trie&quot;)); // System.out.println(trie.search(&quot;insert&quot;)); // System.out.println(trie.search(&quot;word&quot;)); // } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","categories":[],"tags":[{"name":"leetcode Trie","slug":"leetcode-Trie","permalink":"https://jzygaga.github.io/tags/leetcode-Trie/"}]},{"title":"递归入门","slug":"递归入门","date":"2018-12-16T09:01:40.000Z","updated":"2018-12-16T09:01:40.355Z","comments":true,"path":"2018/12/16/递归入门/","link":"","permalink":"https://jzygaga.github.io/2018/12/16/递归入门/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"数据结构--数组","slug":"数据结构-栈","date":"2018-12-14T15:16:31.000Z","updated":"2018-12-14T15:17:28.698Z","comments":true,"path":"2018/12/14/数据结构-栈/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-栈/","excerpt":"","text":"","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"数据结构--数组","slug":"数据结构-BST","date":"2018-12-14T15:16:31.000Z","updated":"2018-12-18T13:56:30.773Z","comments":true,"path":"2018/12/14/数据结构-BST/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-BST/","excerpt":"","text":"二叉搜索树 public class BST&lt;E extends Comparable&lt;E&gt;&gt; { private class Node { public E e; public Node left, right; public Node(E e) { this.e = e; left = null; right = null; } } private Node root; private int size; public BST(){ root = null; size = 0; } public int size(){ return size; } public boolean isEmpty(){ return size == 0; } // 向二分搜索树中添加新的元素e public void add(E e){ if(root == null){ root = new Node(e); size ++; } else add(root, e); } // 向以node为根的二分搜索树中插入元素e，递归算法 private void add(Node node, E e){ if(e.equals(node.e)) return; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null){ node.left = new Node(e); size ++; return; } else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null){ node.right = new Node(e); size ++; return; } if(e.compareTo(node.e) &lt; 0) add(node.left, e); else //e.compareTo(node.e) &gt; 0 add(node.right, e); } }","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"数据结构--数组","slug":"数据结构-数组","date":"2018-12-14T15:16:31.000Z","updated":"2018-12-14T15:17:28.698Z","comments":true,"path":"2018/12/14/数据结构-数组/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-数组/","excerpt":"","text":"","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"数据结构目录","slug":"数据结构-目录","date":"2018-12-14T15:16:18.000Z","updated":"2018-12-14T15:36:03.122Z","comments":true,"path":"2018/12/14/数据结构-目录/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-目录/","excerpt":"","text":"数据结构 数据结构 数组 超强大的云开发平台Coding","categories":[],"tags":[]},{"title":"多线程","slug":"多线程","date":"2018-12-14T05:53:05.000Z","updated":"2019-01-01T12:55:43.675Z","comments":true,"path":"2018/12/14/多线程/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/多线程/","excerpt":"","text":"","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://jzygaga.github.io/tags/多线程/"}]},{"title":"capon","slug":"capon","date":"2018-12-05T06:26:05.000Z","updated":"2018-12-05T15:28:39.356Z","comments":true,"path":"2018/12/05/capon/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/capon/","excerpt":"","text":"哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"https://jzygaga.github.io/tags/项目/"}]},{"title":"我滴妈","slug":"basic12","date":"2018-12-05T06:01:18.000Z","updated":"2018-12-08T18:28:23.052Z","comments":true,"path":"2018/12/05/basic12/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/basic12/","excerpt":"","text":"问题描述123321是一个非常特殊的数，它从左边读和从右边读是一样的。 输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 输入格式 输入一行，包含一个正整数n。 输出格式 按从小到大的顺序输出满足条件的整数，每个整数占一行。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package algorithm.Lanqiao.基础练习; import java.util.Scanner; public class base9 { public static void main(String[] args) { int n; Scanner in = new Scanner(System.in); n = in.nextInt(); in.close(); //5位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } //6位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k * 2 == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } }","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]},{"title":"我滴妈","slug":"蓝桥被入门题第一题","date":"2018-12-05T06:01:18.000Z","updated":"2018-12-08T16:08:25.969Z","comments":true,"path":"2018/12/05/蓝桥被入门题第一题/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/蓝桥被入门题第一题/","excerpt":"","text":"问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package begin4; import java.util.Scanner; public class Main { public static void main(String[] args) { int[] f= new int[1000001]; f[1] = f[2] = 1; for (int i = 3; i &lt;= 1000000; i++) { f[i] = (f[i-1] + f[i-2]) % 10007; } Scanner in = new Scanner(System.in); System.out.println(f[in.nextInt()]); in.close(); } }","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]},{"title":"nihao,exo","slug":"nihao-exo","date":"2018-12-05T05:41:29.000Z","updated":"2018-12-05T05:41:29.959Z","comments":true,"path":"2018/12/05/nihao-exo/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/nihao-exo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-12-05T05:01:55.023Z","updated":"2018-12-05T05:01:55.023Z","comments":true,"path":"2018/12/05/hello-world/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}