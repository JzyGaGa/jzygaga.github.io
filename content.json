{"meta":{"title":"飞翔的傻瓜","subtitle":"菜鸟的试飞之旅","description":null,"author":"FlyingFool","url":"https://jzygaga.github.io"},"pages":[],"posts":[{"title":"斐波那契数列","slug":"剑指offer-斐波那契数列","date":"2019-01-06T06:34:09.000Z","updated":"2019-01-06T09:37:25.042Z","comments":true,"path":"2019/01/06/剑指offer-斐波那契数列/","link":"","permalink":"https://jzygaga.github.io/2019/01/06/剑指offer-斐波那契数列/","excerpt":"","text":"斐波那契数列 描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 代码public int Fibonacci1(int n) { if(n==1) return 1; if(n==2) return 1; int[] arr=new int[n]; arr[0]=1; arr[1]=1; for(int i=2;i&lt;n;i++) { arr[i]=arr[i-1]+arr[i-2]; } return arr[n-1]; } 代码 import java.util.HashMap; import java.util.Map; public class Solution { private Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;(); public int Fibonacci(int n) { if(n==1) return 1; if(n==2) return 1; if(map.get(n)!=null) return map.get(n); map.put(n, Fibonacci(n-1)+Fibonacci(n-2)); return map.get(n); } }","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://jzygaga.github.io/categories/剑指offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://jzygaga.github.io/tags/数组/"}]},{"title":"Powerful Integers","slug":"leetcode-970. Powerful Integers","date":"2019-01-06T05:57:10.000Z","updated":"2019-01-06T06:09:29.352Z","comments":true,"path":"2019/01/06/leetcode-970. Powerful Integers/","link":"","permalink":"https://jzygaga.github.io/2019/01/06/leetcode-970. Powerful Integers/","excerpt":"","text":"970. Powerful Integers 描述：Given two non-negative integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &gt;= 0 and j &gt;= 0. 例子 例子1 Input: x = 2, y = 3, bound = 10Output: [2,3,4,5,7,9,10] Explanation: 2 = 2^0 + 3^0 3 = 2^1 + 3^0 4 = 2^0 + 3^1 5 = 2^1 + 3^1 7 = 2^2 + 3^1 9 = 2^3 + 3^0 10 = 2^0 + 3^2 代码 while class Solution { public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) { int maxV=Math.max(x, y); int minV=Math.min(x, y); int sum; int sumMaxV=1; int sumMinV=1; Set&lt;Integer&gt; set=new HashSet&lt;&gt;(); //3 while(sumMaxV&lt;=bound) { sumMinV=1; while(sumMinV&lt;=(bound-sumMaxV)) { sum=sumMaxV+sumMinV; // if(sum&gt;bound) // break; while()条件已经判断了 set.add(sum); if(minV==1) break; sumMinV*=minV; } sumMaxV*=maxV; if(maxV==1) break; } return new ArrayList&lt;&gt;(set); } } for public List&lt;Integer&gt; powerfulIntegers(int x, int y, int bound) { Set&lt;Integer&gt; result = new HashSet&lt;&gt;(); for (int a = 1; a &lt; bound; a *= x) { for (int b = 1; a + b &lt;= bound; b *= y) { result.add(a + b); if (y == 1) { break; } } if (x == 1) { break; } } return new ArrayList&lt;&gt;(result); } }","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://jzygaga.github.io/tags/数组/"}]},{"title":"图结构","slug":"数据结构-图","date":"2019-01-05T03:01:15.000Z","updated":"2019-01-05T13:36:37.249Z","comments":true,"path":"2019/01/05/数据结构-图/","link":"","permalink":"https://jzygaga.github.io/2019/01/05/数据结构-图/","excerpt":"","text":"图结构 图的分类 有向图，无向图 边上有方向 边上无方向 有权图，无权图 有权图，边上有值。 无权图，边上无值。 图的连通性 判断图之间是否连通 连通分量 边 自环边 平行边 图的表示 邻接矩阵 package graphic; /** * 密集矩阵用邻接矩阵 * @author 59842 * */ public class DenseGraph { //有多少个定点 private int n; //有多少个边 private int m; //是否有向//true表示有向图 private boolean directed; //存储图的有向结构 private boolean[][] g; public DenseGraph(int n, boolean directed) { this.n=n; this.m=0; this.directed=directed; g=new boolean [n][n]; } public void addEdge(int v,int w) { if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n) throw new IllegalArgumentException(&quot;边超出了范围&quot;); if(hasEdge(v,w)) return ; g[v][w]=true; if(!directed) //不是有向图 g[w][v]=true; m++; } private boolean hasEdge(int v, int w) { if(0&lt;=v&amp;&amp;v&lt;n||0&lt;=w&amp;&amp;w&lt;n) throw new IllegalArgumentException(&quot;边超出了范围&quot;); return g[w][v]=false; } public int getV() { return n; } public int getE() { return m; } } 邻接表 完全图 适用的场景，每个电影的相似程度。有权图邻接表适合表示稀疏图，邻接矩阵适合表示稠密图","categories":[{"name":"图结构","slug":"图结构","permalink":"https://jzygaga.github.io/categories/图结构/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"用两个栈实现队列","slug":"剑指offer-用两个栈实现队列","date":"2019-01-04T03:08:18.000Z","updated":"2019-01-04T03:13:44.887Z","comments":true,"path":"2019/01/04/剑指offer-用两个栈实现队列/","link":"","permalink":"https://jzygaga.github.io/2019/01/04/剑指offer-用两个栈实现队列/","excerpt":"","text":"题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 自己解 import java.util.Stack; public class Solution { Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) { stack1.push(node); } public int pop() { while(!stack1.isEmpty()) { stack2.push(stack1.pop()); } Integer toPop = stack2.pop(); while(!stack2.isEmpty()) { stack1.push(stack2.pop()); } return toPop; } } 渐优解","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://jzygaga.github.io/categories/剑指offer/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://jzygaga.github.io/tags/栈/"}]},{"title":"重建二叉树","slug":"剑指offer-重建二叉树","date":"2019-01-04T02:47:53.000Z","updated":"2019-01-04T02:52:54.124Z","comments":true,"path":"2019/01/04/剑指offer-重建二叉树/","link":"","permalink":"https://jzygaga.github.io/2019/01/04/剑指offer-重建二叉树/","excerpt":"","text":"重建二叉树题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 /** * Definition for binary tree * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ public class Solution { public TreeNode reConstructBinaryTree(int [] pre,int [] in) { if(pre==null||in==null||pre.length!=in.length) return null; return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1); } private TreeNode reConstructBinaryTree(int[] pre,int pStart,int pEnd,int[] in,int iStart,int iEnd){ //一般性问题 if(pStart&gt;pEnd) return null; //创建根节点 TreeNode root=new TreeNode(pre[pStart]); //找到中序遍历中的位置 int loc; for(loc=0;loc&lt;in.length;loc++){ if(in[loc]==pre[pStart]){ break; } } //计算左右子树节点的个数。 int len=loc-iStart; root.left=reConstructBinaryTree(pre,pStart+1,pStart+len,in,iStart,iStart+len-1); root.right=reConstructBinaryTree(pre,pStart+len+1,pEnd,in,iStart+len+1,iEnd); return root; } }","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://jzygaga.github.io/categories/剑指offer/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://jzygaga.github.io/tags/二叉树/"}]},{"title":"234. Palindrome Linked List","slug":"leetcode-单链表-234. Palindrome Linked List","date":"2019-01-03T06:32:36.000Z","updated":"2019-01-03T06:38:51.711Z","comments":true,"path":"2019/01/03/leetcode-单链表-234. Palindrome Linked List/","link":"","permalink":"https://jzygaga.github.io/2019/01/03/leetcode-单链表-234. Palindrome Linked List/","excerpt":"","text":"Palindrome Linked List 描述：Given a singly linked list, determine if it is a palindrome. 例子： Input: 1-&gt;2 ，Output: false Input: 1-&gt;2-&gt;2-&gt;1，Output: true 代码1","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"单链表","slug":"单链表","permalink":"https://jzygaga.github.io/tags/单链表/"}]},{"title":"206. Reverse Linked List","slug":"leetcode-206. Reverse Linked List","date":"2019-01-03T04:18:55.000Z","updated":"2019-01-03T05:51:01.841Z","comments":true,"path":"2019/01/03/leetcode-206. Reverse Linked List/","link":"","permalink":"https://jzygaga.github.io/2019/01/03/leetcode-206. Reverse Linked List/","excerpt":"","text":"Reverse Linked ListReverse a singly linked list. Example: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 代码 迭代的代码 class Solution { public ListNode reverseList(ListNode head) { ListNode reverseNode=null; ListNode cur=head; ListNode toDeal=null; while(cur!=null) { //拿到待处理的节点 toDeal =cur; cur=cur.next; //拿到一边进行连接 toDeal.next=reverseNode; reverseNode=toDeal; } return reverseNode; } } 递归的代码代码一 class Solution { public ListNode reverseList(ListNode head) { if(head==null||head.next==null) return head; return toReverse(head,null); } private ListNode toReverse(ListNode head, ListNode reverse) { if(head==null) { return reverse; } ListNode cur=head.next; //与另一个链表相连接 head.next=reverse; // reverse=head; return toReverse(cur,reverse); } } 代码二 public ListNode reverseList(ListNode head) { if(head==null||head.next==null) return head; ListNode newHead= reverseList(head.next); //两个借点之间的链接进行翻转 head.next.next=head; head.next=null; return newHead; }","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://jzygaga.github.io/tags/链表/"}]},{"title":"Middle of the Linked List","slug":"leetcode-876. Middle of the Linked List","date":"2019-01-02T22:05:24.000Z","updated":"2019-01-02T22:54:08.431Z","comments":true,"path":"2019/01/03/leetcode-876. Middle of the Linked List/","link":"","permalink":"https://jzygaga.github.io/2019/01/03/leetcode-876. Middle of the Linked List/","excerpt":"","text":"876. Middle of the Linked List描述 Given a non-empty, singly linked list with head node head, return a middle node of linked list.if there are two middle nodes, return the second middle node. Example 1: Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge’s serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. Example 2： Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge’s serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL. 代码一 class Solution { public ListNode middleNode(ListNode head) { ListNode node=head; int i=0; while(node!=null) { i++; node=node.next; } int loc=i/2+1; i=1; ListNode node1=head; while(i&lt;loc) { node1=node1.next; i++; } return node1; } } 代码二public ListNode middleNode(ListNode head) { ListNode listNode = new ListNode(0); ListNode fast=head; ListNode low=head; while(fast!=null&amp;&amp;fast.next!=null) { fast=fast.next.next; low=low.next; } return low.next; } 代码三 class Solution { public ListNode middleNode(ListNode head) { ListNode fast=head; ListNode low=head; //对比2方法，假装自己先跑了两步 if(fast!=null&amp;&amp;fast.next!=null){ fast=fast.next.next; }else{ return low; } while(fast!=null&amp;&amp;fast.next!=null) { fast=fast.next.next; low=low.next; } return low.next; } } 代码四public ListNode middleNode(ListNode head) { ListNode fast=head; ListNode low=head; //对比2方法，假装自己先跑了两步 if(head==null&amp;&amp;head.next==null) return head; while(fast!=null&amp;&amp;fast.next!=null) { fast=fast.next.next; low=low.next; } return low; }","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://jzygaga.github.io/tags/链表/"}]},{"title":"二维数组中的查找","slug":"剑指offer-二维数组中的查找 ","date":"2019-01-02T06:19:14.000Z","updated":"2019-01-03T08:21:57.515Z","comments":true,"path":"2019/01/02/剑指offer-二维数组中的查找 /","link":"","permalink":"https://jzygaga.github.io/2019/01/02/剑指offer-二维数组中的查找 /","excerpt":"","text":"二维数组中的查找描述： 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。代码 public class Solution { public boolean Find(int target, int [][] array) { int y=0; int x=array.length-1; int row=array.length-1; int col=array[0].length-1; while((0&lt;=x&amp;&amp;x&lt;=col)&amp;&amp;(0&lt;=y&amp;&amp;y&lt;=row)){ if(array[x][y]==target) return true; if(array[x][y]&lt;target){ y++; continue; } if(array[x][y]&gt;target){ x--; continue; } } return false; } } 注意数组根据先后赋值，排列是从上到下来的","categories":[{"name":"剑指offer","slug":"剑指offer","permalink":"https://jzygaga.github.io/categories/剑指offer/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://jzygaga.github.io/tags/数组/"}]},{"title":"反射","slug":"java-反射","date":"2019-01-02T05:34:53.000Z","updated":"2019-01-02T06:16:14.561Z","comments":true,"path":"2019/01/02/java-反射/","link":"","permalink":"https://jzygaga.github.io/2019/01/02/java-反射/","excerpt":"","text":"对方的付费","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"反射","slug":"反射","permalink":"https://jzygaga.github.io/tags/反射/"}]},{"title":"工厂模式","slug":"设计模式-代理模式","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T05:15:53.836Z","comments":true,"path":"2019/01/01/设计模式-代理模式/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/设计模式-代理模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jzygaga.github.io/categories/设计模式/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://jzygaga.github.io/tags/代理模式/"}]},{"title":"工厂模式","slug":"设计模式-工产模式","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T05:10:24.762Z","comments":true,"path":"2019/01/01/设计模式-工产模式/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/设计模式-工产模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jzygaga.github.io/categories/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://jzygaga.github.io/tags/工厂模式/"}]},{"title":"红黑树","slug":"数据结构-红黑树","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T07:48:33.848Z","comments":true,"path":"2019/01/01/数据结构-红黑树/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/数据结构-红黑树/","excerpt":"","text":"红黑树 红黑树定义 算法导论的定义 满二叉树 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空 AVL 定义每一个节点的高度 计算平衡因子 定义： 每个节点的平衡因子等于左子树减去右子树的差 作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的 AVL的左旋转右旋转 当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。 package AVLTree; import java.util.ArrayList; public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private class Node{ public K key; public V value; public Node left, right; public int height; public Node(K key, V value){ this.key = key; this.value = value; left = null; right = null; height = 1; } } private Node root; private int size; public AVLTree(){ root = null; size = 0; } public int getSize(){ return size; } public boolean isEmpty(){ return size == 0; } // 获得节点node的高度 private int getHeight(Node node){ if(node == null) return 0; return node.height; } // 获得节点node的平衡因子 private int getBalanceFactor(Node node){ if(node == null) return 0; return getHeight(node.left) - getHeight(node.right); } // 向二分搜索树中添加新的元素(key, value) public void add(K key, V value){ root = add(root, key, value); } // 向以node为根的二分搜索树中插入元素(key, value)，递归算法 // 返回插入新节点后二分搜索树的根 private Node add(Node node, K key, V value){ if(node == null){ size ++; return new Node(key, value); } if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // 更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0) return rightRotate(node); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0) return leftRotate(node); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) { //先进行左旋 node.left= leftRotate(node.left); return rightRotate(node); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) { node.right=rightRotate(node.right); return leftRotate(node); } return node; } //对节点进行左旋操作，返回旋转后的新节点X // y x // / \\ / \\ // T1 x 向右旋转(y),左侧过高不平衡 y z // / \\ ----------------------&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T4 T3 // private Node leftRotate(Node y) { Node x=y.right; Node T2=x.right; //向右旋转过程 x.left=y; y.right=T2; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } //对节点进行右旋操作，返回旋转后的新节点X // y x // / \\ / \\ // x T4 向右旋转(y),左侧过高不平衡 z y // / \\ ----------------------&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 // 返回以node为根节点的二分搜索树中，key所在的节点 private Node rightRotate(Node y) { Node x=y.left; Node T3=x.right; //向右旋转过程 x.right=y; y.left=T3; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } private Node getNode(Node node, K key){ if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); } public boolean contains(K key){ return getNode(root, key) != null; } public V get(K key){ Node node = getNode(root, key); return node == null ? null : node.value; } public void set(K key, V newValue){ Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;); node.value = newValue; } // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node){ if(node.left == null) return node; return minimum(node.left); } // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node){ if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } node.left = removeMin(node.left); return node; } // 从二分搜索树中删除键为key的节点 public V remove(K key){ Node node = getNode(root, key); if(node != null){ root = remove(root, key); return node.value; } return null; } private Node remove(Node node, K key){ if( node == null ) return null; Node retNode; if( key.compareTo(node.key) &lt; 0 ){ node.left = remove(node.left , key); retNode= node; } else if(key.compareTo(node.key) &gt; 0 ){ node.right = remove(node.right, key); retNode= node; } else{ // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null){ Node rightNode = node.right; node.right = null; size --; retNode= rightNode; }else if(node.right == null){ // 待删除节点右子树为空的情况 Node leftNode = node.left; node.left = null; size --; retNode= leftNode; }else { // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = remove(node.right,successor.key); successor.left = node.left; node.left = node.right = null; retNode= successor; } } if(retNode==null) return retNode; // 更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); int balanceFactor = getBalanceFactor(retNode); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0) return rightRotate(retNode); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0) return leftRotate(retNode); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) { //先进行左旋 node.left= leftRotate(retNode.left); return rightRotate(retNode); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) { retNode.right=rightRotate(retNode.right); return leftRotate(retNode); } return retNode; } public static void main(String[] args){ System.out.println(&quot;Pride and Prejudice&quot;); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) { System.out.println(&quot;Total words: &quot; + words.size()); AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;(); for (String word : words) { if (map.contains(word)) map.set(word, map.get(word) + 1); else map.add(word, 1); } System.out.println(&quot;Total different words: &quot; + map.getSize()); System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;)); System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;)); System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST()); System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced()); for(String word:words) { map.remove(word); if(!map.isBalanced()||!map.isBST()) { throw new RuntimeException(&quot;error！&quot;); } } } System.out.println(); } public boolean isBST() { //BST在中序边遍历是从小到大来的 ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;(); inOrder(root,keys); for(int i=1;i&lt;keys.size();i++) //注意i-1 if(keys.get(i-1).compareTo(keys.get(i))&gt;0) return false; return true; } private void inOrder(Node root, ArrayList&lt;K&gt; keys) { if(root==null) return ; inOrder(root.left, keys); keys.add(root.key); inOrder(root.right, keys); } //判断二叉树是否是一颗平衡二叉树 public boolean isBalanced() { return isBalanced(root); } //判断以Node为根的二叉树是平衡二叉树，递归算法 public boolean isBalanced(Node node) { if(node==null) return true; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor)&gt;1) return false; return isBalanced(node.left)&amp;&amp;isBalanced(node.right); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"红黑树","slug":"红黑树","permalink":"https://jzygaga.github.io/tags/红黑树/"}]},{"title":"AVL树","slug":"数据结构-AVL树","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T07:53:15.273Z","comments":true,"path":"2019/01/01/数据结构-AVL树/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/数据结构-AVL树/","excerpt":"","text":"AVL树 平衡二叉树的定义 对于任意一个节点，左子树和右子树的高度差不能超过1 AVL树有着自己的平衡性，所以在自己的增加和删除，不会退化成一个链表 满二叉树 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树，会存在一个非叶子节点右子树为空 AVL 定义每一个节点的高度 计算平衡因子 定义： 每个节点的平衡因子等于左子树减去右子树的差 作用： 如果Math.abs(平衡因子)&gt;1，那么左右子树就是不平衡的 AVL的左旋转右旋转 当插入一个元素之后，就会破坏原有的平衡。如果是插入节点后，回溯到第一个不平衡的点，如果是左子树的左节点过长就叫LL.如果是左子树的右节点过长就叫LR。如果是右子树的右节点过长就叫RR。如果是右子书的左节点过长就叫LR。*对于LR先进行左旋在进行右旋就可以转换成功。对于RL先进行右旋在进行左旋就可以转换成功。 package AVLTree; import java.util.ArrayList; public class AVLTree&lt;K extends Comparable&lt;K&gt;, V&gt; { private class Node{ public K key; public V value; public Node left, right; public int height; public Node(K key, V value){ this.key = key; this.value = value; left = null; right = null; height = 1; } } private Node root; private int size; public AVLTree(){ root = null; size = 0; } public int getSize(){ return size; } public boolean isEmpty(){ return size == 0; } // 获得节点node的高度 private int getHeight(Node node){ if(node == null) return 0; return node.height; } // 获得节点node的平衡因子 private int getBalanceFactor(Node node){ if(node == null) return 0; return getHeight(node.left) - getHeight(node.right); } // 向二分搜索树中添加新的元素(key, value) public void add(K key, V value){ root = add(root, key, value); } // 向以node为根的二分搜索树中插入元素(key, value)，递归算法 // 返回插入新节点后二分搜索树的根 private Node add(Node node, K key, V value){ if(node == null){ size ++; return new Node(key, value); } if(key.compareTo(node.key) &lt; 0) node.left = add(node.left, key, value); else if(key.compareTo(node.key) &gt; 0) node.right = add(node.right, key, value); else // key.compareTo(node.key) == 0 node.value = value; // 更新height node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right)); int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&gt;=0) return rightRotate(node); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&lt;=0) return leftRotate(node); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(node.left)&lt;0) { //先进行左旋 node.left= leftRotate(node.left); return rightRotate(node); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(node.right)&gt;0) { node.right=rightRotate(node.right); return leftRotate(node); } return node; } //对节点进行左旋操作，返回旋转后的新节点X // y x // / \\ / \\ // T1 x 向右旋转(y),左侧过高不平衡 y z // / \\ ----------------------&gt; / \\ / \\ // T2 z T1 T2 T3 T4 // / \\ // T4 T3 // private Node leftRotate(Node y) { Node x=y.right; Node T2=x.right; //向右旋转过程 x.left=y; y.right=T2; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } //对节点进行右旋操作，返回旋转后的新节点X // y x // / \\ / \\ // x T4 向右旋转(y),左侧过高不平衡 z y // / \\ ----------------------&gt; / \\ / \\ // z T3 T1 T2 T3 T4 // / \\ // T1 T2 // 返回以node为根节点的二分搜索树中，key所在的节点 private Node rightRotate(Node y) { Node x=y.left; Node T3=x.right; //向右旋转过程 x.right=y; y.left=T3; //更新height,只有x,y的位置移动了 y.height=Math.max(getHeight(y.left), getHeight(y.right)); x.height=Math.max(getHeight(x.left), getHeight(x.right)); return y; } private Node getNode(Node node, K key){ if(node == null) return null; if(key.equals(node.key)) return node; else if(key.compareTo(node.key) &lt; 0) return getNode(node.left, key); else // if(key.compareTo(node.key) &gt; 0) return getNode(node.right, key); } public boolean contains(K key){ return getNode(root, key) != null; } public V get(K key){ Node node = getNode(root, key); return node == null ? null : node.value; } public void set(K key, V newValue){ Node node = getNode(root, key); if(node == null) throw new IllegalArgumentException(key + &quot; doesn&apos;t exist!&quot;); node.value = newValue; } // 返回以node为根的二分搜索树的最小值所在的节点 private Node minimum(Node node){ if(node.left == null) return node; return minimum(node.left); } // 删除掉以node为根的二分搜索树中的最小节点 // 返回删除节点后新的二分搜索树的根 private Node removeMin(Node node){ if(node.left == null){ Node rightNode = node.right; node.right = null; size --; return rightNode; } node.left = removeMin(node.left); return node; } // 从二分搜索树中删除键为key的节点 public V remove(K key){ Node node = getNode(root, key); if(node != null){ root = remove(root, key); return node.value; } return null; } private Node remove(Node node, K key){ if( node == null ) return null; Node retNode; if( key.compareTo(node.key) &lt; 0 ){ node.left = remove(node.left , key); retNode= node; } else if(key.compareTo(node.key) &gt; 0 ){ node.right = remove(node.right, key); retNode= node; } else{ // key.compareTo(node.key) == 0 // 待删除节点左子树为空的情况 if(node.left == null){ Node rightNode = node.right; node.right = null; size --; retNode= rightNode; }else if(node.right == null){ // 待删除节点右子树为空的情况 Node leftNode = node.left; node.left = null; size --; retNode= leftNode; }else { // 待删除节点左右子树均不为空的情况 // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点 // 用这个节点顶替待删除节点的位置 Node successor = minimum(node.right); successor.right = remove(node.right,successor.key); successor.left = node.left; node.left = node.right = null; retNode= successor; } } if(retNode==null) return retNode; // 更新height retNode.height = 1 + Math.max(getHeight(retNode.left), getHeight(retNode.right)); int balanceFactor = getBalanceFactor(retNode); if(Math.abs(balanceFactor) &gt; 1) System.out.println(&quot;unbalanced : &quot; + balanceFactor); //平衡维护 //LL if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&gt;=0) return rightRotate(retNode); //RR if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&lt;=0) return leftRotate(retNode); //LR 因为左子树的右子书过长 if(balanceFactor&gt;1&amp;&amp;getBalanceFactor(retNode.left)&lt;0) { //先进行左旋 node.left= leftRotate(retNode.left); return rightRotate(retNode); } //RL 因为右子树的左子树过长 if(balanceFactor&lt;-1&amp;&amp;getBalanceFactor(retNode.right)&gt;0) { retNode.right=rightRotate(retNode.right); return leftRotate(retNode); } return retNode; } public static void main(String[] args){ System.out.println(&quot;Pride and Prejudice&quot;); ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) { System.out.println(&quot;Total words: &quot; + words.size()); AVLTree&lt;String, Integer&gt; map = new AVLTree&lt;&gt;(); for (String word : words) { if (map.contains(word)) map.set(word, map.get(word) + 1); else map.add(word, 1); } System.out.println(&quot;Total different words: &quot; + map.getSize()); System.out.println(&quot;Frequency of PRIDE: &quot; + map.get(&quot;pride&quot;)); System.out.println(&quot;Frequency of PREJUDICE: &quot; + map.get(&quot;prejudice&quot;)); System.out.println(&quot;是否是一个BSTtree：：：：&quot;+map.isBST()); System.out.println(&quot;是否是一个isBalanced：：：：&quot;+map.isBalanced()); for(String word:words) { map.remove(word); if(!map.isBalanced()||!map.isBST()) { throw new RuntimeException(&quot;error！&quot;); } } } System.out.println(); } public boolean isBST() { //BST在中序边遍历是从小到大来的 ArrayList&lt;K&gt; keys=new ArrayList&lt;&gt;(); inOrder(root,keys); for(int i=1;i&lt;keys.size();i++) //注意i-1 if(keys.get(i-1).compareTo(keys.get(i))&gt;0) return false; return true; } private void inOrder(Node root, ArrayList&lt;K&gt; keys) { if(root==null) return ; inOrder(root.left, keys); keys.add(root.key); inOrder(root.right, keys); } //判断二叉树是否是一颗平衡二叉树 public boolean isBalanced() { return isBalanced(root); } //判断以Node为根的二叉树是平衡二叉树，递归算法 public boolean isBalanced(Node node) { if(node==null) return true; int balanceFactor = getBalanceFactor(node); if(Math.abs(balanceFactor)&gt;1) return false; return isBalanced(node.left)&amp;&amp;isBalanced(node.right); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"AVL树","slug":"AVL树","permalink":"https://jzygaga.github.io/tags/AVL树/"}]},{"title":"计算机网络基础","slug":"计算机网络","date":"2019-01-01T09:27:13.000Z","updated":"2019-01-02T06:24:02.162Z","comments":true,"path":"2019/01/01/计算机网络/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/计算机网络/","excerpt":"","text":"计算机网络的分层 应用层：数据服务那个协议。 传输层：解决出错重传机制， 网络层： 数据链路层： 物理层：不可靠，不安全。发展时代：物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;应用层， 不可靠，不安全。对数据的检验，数据服务那个协议，出错重传，应用协议。 网络传输的不可靠 丢包，重复包 出错 乱序滑动窗口 问题提出 改进方案 功能 增加吞吐量，提高效率。 一直等5的ack接受信号，整个接受5ack信号，接受到5返回整个接受ack信息。比如，未接受到5的ack信息，即使接收到6，7，8，9，10，11也不会发送ack信息 wireshark Src：IntelCor电脑 Dst:到路由器 链路层 Src:本机的ip地址 Dst:DNS服务器","categories":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jzygaga.github.io/categories/计算机网络/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://jzygaga.github.io/tags/计算机网络/"}]},{"title":"哈希表","slug":"数据结构-哈希表","date":"2018-12-30T06:57:43.000Z","updated":"2019-01-02T07:48:35.645Z","comments":true,"path":"2018/12/30/数据结构-哈希表/","link":"","permalink":"https://jzygaga.github.io/2018/12/30/数据结构-哈希表/","excerpt":"","text":"哈希表导学例子：387. First Unique Character in a StringGiven a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1. Examples: s = &quot;leetcode&quot; return 0. s = &quot;loveleetcode&quot;, return 2. 代码 class Solution { public int firstUniqChar(String s) { int[] arr=new int[26]; for(int i=0;i&lt;s.length();i++){ arr[s.charAt(i)-&apos;a&apos;]++; } for(int i=0;i&lt;s.length();i++){ if(arr[s.charAt(i)-&apos;a&apos;]==1) return i; } return -1; } } 什么是哈希表 对于我们所关注的内容，比如例子中的字符串，我们建立字符串与我们想要得到值之间的索引的数据结构，我们称之为哈希表。 对于转换的过程我们称之为哈希函数。f(ch)=ch-‘a’; 哈希函数就是把’键’转换成’索引’，如果不同的健对应相同值称之为哈希冲突。 学习哈希表主要解决的问题： 把键转换成索引 解决哈希冲突 哈希表充分体现了算法设计思想：空间换时间。 通过健得到索引分越均匀越好。 哈希函数的设计 对于整型 小范围的正整数正常使用 小范围的负整数进行偏移 -100~100-0~200 大整数 比如身份证号码110108198512166666 选择模一个素数。 浮点型转换成整型 字符串 转成整型处理 166 1100+610+6*1 code c26^3+o26^2+d26^1+e26^0; hash(code)=(cB^3+oB^2+dB^1+eB^0)%M; 设计哈希函数的原则： 一致性：如果a==b,则hash(a)==hash(b) 高效性：计算高校便捷 均匀性：哈希值均匀分布 java中的hashcodepackage Hashtable; public class Student { private int grade; private int cls; private String firstName; private String lastName; public Student(int grade, int cls, String firstName, String lastName) { this.grade = grade; this.cls = cls; this.firstName = firstName; this.lastName = lastName; } @Override public int hashCode() { int B=31; int hash=0; hash=hash*B+grade; hash=hash*B+cls; //不区分大小写。。 hash=hash*B+firstName.hashCode(); hash=hash*B+lastName.hashCode(); return hash; } } java中解决hashcode的方法 Seperate Chaining (hashCode(k1)&amp;0x7fffffff)%M 根据hash值就算出索引 如果产生冲突了，就在后面添加一个，就相当于每个索引后面接一个链表，但是我们为了优化访问的速度，可以接一个红黑树。 k2-&gt;k3相当于一个查找表。所以hashMap就相当于treemap的数组，HashSet相当于treeSet数组。 在java8之前每一个位置对应一个链表，java8之后一开始一个位置对应一个链表，当哈希冲突达到一定程度每一个位置从链表变成红黑树，在数量小的时候红黑树会进行反转等操作。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"哈希表","slug":"哈希表","permalink":"https://jzygaga.github.io/tags/哈希表/"}]},{"title":"lamda","slug":"java-lamda","date":"2018-12-29T09:07:54.000Z","updated":"2019-01-01T12:33:44.722Z","comments":true,"path":"2018/12/29/java-lamda/","link":"","permalink":"https://jzygaga.github.io/2018/12/29/java-lamda/","excerpt":"","text":"JAVA8新特性——Lamda表达式Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。 先来看看传统的匿名内部类调用方式: interface MyInterface{ void lMethod(); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(); } public static void main(String[] args) { test(new MyInterface() { @Override public void lMethod() { System.out.println(&quot;Hello World!&quot;); } }); } } 在主类中的这么几行代码，嵌套几层就为了输出一个Hello World！是不是很麻烦？但是由于java结构的完整性，我们还不得不那么做，现在JDK1.8来了。 再来看看使用Lamda表达式改写上面的代码： interface Myinterface{ void IMethod(); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(); } public static void main(String[] args) { test(()-&gt; System.out.println(&quot;666&quot;)); } } 这就是Lamda表达式语言，为了解决匿名内部类繁杂的操作而出现。 Lamda语法有三种形式： (参数) -&gt;单行语句； (参数) -&gt;{多行语句}； (参数) -&gt;表达式；括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&gt;System.out.println(“Hello World!”) 前面的()代表void lMethod()方法，它没有入参，所以为空，-&gt;后面是一个单行语句；如果-&gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;-&gt;后面也可以是一个表达式，如：a+b等。 (参数) -&gt;单行语句； interface MyInterface{ void lMethod(String str); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(&quot;Hello World!&quot;);//设置参数内容 } public static void main(String[] args) { //首先在()中定义此表达式里面需要接收变量s，后面的单行语句中就可以使用该变量了 test((s)-&gt;System.out.println(s)); } } (参数) -&gt;多行语句； interface Myinterface{ void IMethod(String str); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(&quot;hello word&quot;); } public static void main(String[] args) { test((s)-&gt; { s=s+s; System.out.println(s); }); } } 这样，Lamda表达式就看起来很简单了，有不有！ 匿名内部类，我们比较常用的地方在哪儿？线程类Thread，以前我们可能这样写： 总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"lamda","slug":"lamda","permalink":"https://jzygaga.github.io/tags/lamda/"}]},{"title":"并查集","slug":"数据结构-并查集","date":"2018-12-22T03:44:56.000Z","updated":"2019-01-02T07:44:40.976Z","comments":true,"path":"2018/12/22/数据结构-并查集/","link":"","permalink":"https://jzygaga.github.io/2018/12/22/数据结构-并查集/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/categories/数据结构/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://jzygaga.github.io/tags/并查集/"}]},{"title":"leetcode","slug":"leetcode-208. Implement Trie (Prefix Tree) - 副本","date":"2018-12-20T11:36:27.000Z","updated":"2019-01-02T05:33:20.270Z","comments":true,"path":"2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","excerpt":"","text":"208. Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. 描述Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // returns truetrie.search(“app”); // returns falsetrie.startsWith(“app”); // returns truetrie.insert(“app”);trie.search(“app”); // returns true * 代码class Trie { private class Node { public boolean isWord; public TreeMap&lt;Character, Node&gt; next; public Node(boolean isWord) { next = new TreeMap&lt;&gt;(); this.isWord = isWord; } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public Trie() { root=new Node(); size=0; } /** Inserts a word into the trie. */ public void insert(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); Node node = cur.next.get(c); if(node==null) cur.next.put(c, new Node()); cur=cur.next.get(c); } cur.isWord=true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return cur.isWord; } /** * Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Node cur=root; for(int i=0;i&lt;prefix.length();i++) { char c = prefix.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return true; } // public static void main(String[] args) { // String[] arr= {&quot;Trie&quot;,&quot;insert&quot;,&quot;search&quot;,&quot;startWith&quot;,&quot;insert&quot;,&quot;search&quot;}; // Trie trie = new Trie(); // for(int i=0;i&lt;arr.length;i++) // trie.insert(arr[i]); // System.out.println(trie.startsWith(&quot;tr&quot;)); // System.out.println(trie.startsWith(&quot;in&quot;)); // System.out.println(trie.startsWith(&quot;sea&quot;)); // System.out.println(trie.search(&quot;Trie&quot;)); // System.out.println(trie.search(&quot;insert&quot;)); // System.out.println(trie.search(&quot;word&quot;)); // } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"https://jzygaga.github.io/tags/Trie/"}]},{"title":"leetcode","slug":"leetcode-211. Add and Search Word - Data structure design","date":"2018-12-20T11:36:27.000Z","updated":"2019-01-02T06:09:38.223Z","comments":true,"path":"2018/12/20/leetcode-211. Add and Search Word - Data structure design/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/leetcode-211. Add and Search Word - Data structure design/","excerpt":"","text":"211. Add and Search Word - Data structure design Design a data structure that supports the following two operations: 描述addWord(&quot;bad&quot;) addWord(&quot;dad&quot;) addWord(&quot;mad&quot;) search(&quot;pad&quot;) -&gt; false search(&quot;bad&quot;) -&gt; true search(&quot;.ad&quot;) -&gt; true search(&quot;b..&quot;) -&gt; true 代码class WordDictionary { private class Node{ public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) { this.isWord=isWord; next=new TreeMap&lt;&gt;(); } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public WordDictionary() { root=new Node(); size=0; } /** Adds a word into the data structure. */ public void addWord(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { cur.next.put(c, new Node()); } cur=cur.next.get(c); } cur.isWord=true; size++; } /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */ public boolean search(String word) { int i=0; Node cur=root; return recurtionSearch(i,word,cur); } private boolean recurtionSearch(int i,String str,Node cur) { if(i==str.length()) return cur.isWord; char m=str.charAt(i); if(m!=&apos;.&apos;) { if(cur.next.get(m)==null) return false; return recurtionSearch(++i, str,cur.next.get(m)); }else { //这个逻辑，就跳过点.这个位置 for(char c:cur.next.keySet()) if(recurtionSearch(++i, str,cur.next.get(c))) return true; return false; } } // public static void main(String[] args) { // WordDictionary wordDictionary = new WordDictionary(); // wordDictionary.addWord(&quot;123&quot;); // ; // System.out.println(wordDictionary.search(&quot;.3&quot;)); // } } /** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"https://jzygaga.github.io/tags/Trie/"}]},{"title":"数据结构--数组","slug":"数据结构-BST","date":"2018-12-14T15:16:31.000Z","updated":"2018-12-18T13:56:30.773Z","comments":true,"path":"2018/12/14/数据结构-BST/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-BST/","excerpt":"","text":"二叉搜索树 public class BST&lt;E extends Comparable&lt;E&gt;&gt; { private class Node { public E e; public Node left, right; public Node(E e) { this.e = e; left = null; right = null; } } private Node root; private int size; public BST(){ root = null; size = 0; } public int size(){ return size; } public boolean isEmpty(){ return size == 0; } // 向二分搜索树中添加新的元素e public void add(E e){ if(root == null){ root = new Node(e); size ++; } else add(root, e); } // 向以node为根的二分搜索树中插入元素e，递归算法 private void add(Node node, E e){ if(e.equals(node.e)) return; else if(e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null){ node.left = new Node(e); size ++; return; } else if(e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null){ node.right = new Node(e); size ++; return; } if(e.compareTo(node.e) &lt; 0) add(node.left, e); else //e.compareTo(node.e) &gt; 0 add(node.right, e); } }","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"数据结构--数组","slug":"数据结构-栈","date":"2018-12-14T15:16:31.000Z","updated":"2018-12-14T15:17:28.698Z","comments":true,"path":"2018/12/14/数据结构-栈/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/数据结构-栈/","excerpt":"","text":"","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://jzygaga.github.io/tags/数据结构/"}]},{"title":"多线程","slug":"java-多线程","date":"2018-12-14T05:53:05.000Z","updated":"2019-01-02T06:23:32.010Z","comments":true,"path":"2018/12/14/java-多线程/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/java-多线程/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://jzygaga.github.io/tags/多线程/"}]},{"title":"basic12","slug":"蓝桥杯-basic12","date":"2018-12-05T06:01:18.000Z","updated":"2019-01-02T06:28:58.388Z","comments":true,"path":"2018/12/05/蓝桥杯-basic12/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/蓝桥杯-basic12/","excerpt":"","text":"问题描述123321是一个非常特殊的数，它从左边读和从右边读是一样的。 输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 输入格式 输入一行，包含一个正整数n。 输出格式 按从小到大的顺序输出满足条件的整数，每个整数占一行。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package algorithm.Lanqiao.基础练习; import java.util.Scanner; public class base9 { public static void main(String[] args) { int n; Scanner in = new Scanner(System.in); n = in.nextInt(); in.close(); //5位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } //6位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k * 2 == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } }","categories":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/categories/蓝桥杯/"}],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]},{"title":"我滴妈","slug":"蓝桥被入门题第一题","date":"2018-12-05T06:01:18.000Z","updated":"2018-12-08T16:08:25.969Z","comments":true,"path":"2018/12/05/蓝桥被入门题第一题/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/蓝桥被入门题第一题/","excerpt":"","text":"问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package begin4; import java.util.Scanner; public class Main { public static void main(String[] args) { int[] f= new int[1000001]; f[1] = f[2] = 1; for (int i = 3; i &lt;= 1000000; i++) { f[i] = (f[i-1] + f[i-2]) % 10007; } Scanner in = new Scanner(System.in); System.out.println(f[in.nextInt()]); in.close(); } }","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]}]}