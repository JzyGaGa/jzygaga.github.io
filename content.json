{"meta":{"title":"飞翔的傻瓜","subtitle":"菜鸟的试飞之旅","description":null,"author":"FlyingFool","url":"https://jzygaga.github.io"},"pages":[],"posts":[{"title":"准备编辑的博客","slug":"准备编辑的博客","date":"2019-01-02T05:34:46.000Z","updated":"2019-01-02T05:34:46.524Z","comments":true,"path":"2019/01/02/准备编辑的博客/","link":"","permalink":"https://jzygaga.github.io/2019/01/02/准备编辑的博客/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"工厂模式","slug":"设计模式-代理模式","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T05:15:53.836Z","comments":true,"path":"2019/01/01/设计模式-代理模式/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/设计模式-代理模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jzygaga.github.io/categories/设计模式/"}],"tags":[{"name":"代理模式","slug":"代理模式","permalink":"https://jzygaga.github.io/tags/代理模式/"}]},{"title":"工厂模式","slug":"设计模式-工产模式","date":"2019-01-01T12:53:48.000Z","updated":"2019-01-02T05:10:24.762Z","comments":true,"path":"2019/01/01/设计模式-工产模式/","link":"","permalink":"https://jzygaga.github.io/2019/01/01/设计模式-工产模式/","excerpt":"","text":"","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://jzygaga.github.io/categories/设计模式/"}],"tags":[{"name":"工厂模式","slug":"工厂模式","permalink":"https://jzygaga.github.io/tags/工厂模式/"}]},{"title":"lamda","slug":"lamda","date":"2018-12-29T09:07:54.000Z","updated":"2019-01-01T12:33:44.722Z","comments":true,"path":"2018/12/29/lamda/","link":"","permalink":"https://jzygaga.github.io/2018/12/29/lamda/","excerpt":"","text":"JAVA8新特性——Lamda表达式Lamda表达式，读作λ表达式，它实质属于函数式编程的概念，要理解函数式编程的产生目的，就要先理解匿名内部类。 先来看看传统的匿名内部类调用方式: interface MyInterface{ void lMethod(); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(); } public static void main(String[] args) { test(new MyInterface() { @Override public void lMethod() { System.out.println(&quot;Hello World!&quot;); } }); } } 在主类中的这么几行代码，嵌套几层就为了输出一个Hello World！是不是很麻烦？但是由于java结构的完整性，我们还不得不那么做，现在JDK1.8来了。 再来看看使用Lamda表达式改写上面的代码： interface Myinterface{ void IMethod(); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(); } public static void main(String[] args) { test(()-&gt; System.out.println(&quot;666&quot;)); } } 这就是Lamda表达式语言，为了解决匿名内部类繁杂的操作而出现。 Lamda语法有三种形式： (参数) -&gt;单行语句； (参数) -&gt;{多行语句}； (参数) -&gt;表达式；括号（）可以大致理解为就是方法，里面是参数变量，在上面的例子中()-&gt;System.out.println(“Hello World!”) 前面的()代表void lMethod()方法，它没有入参，所以为空，-&gt;后面是一个单行语句；如果-&gt;后面是多行语句，需要用{ }装起来，每条语句后需要有分号;-&gt;后面也可以是一个表达式，如：a+b等。 (参数) -&gt;单行语句； interface MyInterface{ void lMethod(String str); } public class Main { public static void test(MyInterface myInterface){ myInterface.lMethod(&quot;Hello World!&quot;);//设置参数内容 } public static void main(String[] args) { //首先在()中定义此表达式里面需要接收变量s，后面的单行语句中就可以使用该变量了 test((s)-&gt;System.out.println(s)); } } (参数) -&gt;多行语句； interface Myinterface{ void IMethod(String str); } public class Main { public static void test(Myinterface myinterface){ myinterface.IMethod(&quot;hello word&quot;); } public static void main(String[] args) { test((s)-&gt; { s=s+s; System.out.println(s); }); } } 这样，Lamda表达式就看起来很简单了，有不有！ 匿名内部类，我们比较常用的地方在哪儿？线程类Thread，以前我们可能这样写： 总结：利用Lamda表达式是为了避免匿名内部类定义过多无用的操作。","categories":[{"name":"java","slug":"java","permalink":"https://jzygaga.github.io/categories/java/"}],"tags":[{"name":"lamda","slug":"lamda","permalink":"https://jzygaga.github.io/tags/lamda/"}]},{"title":"leetcode","slug":"211. Add and Search Word - Data structure design","date":"2018-12-20T11:36:27.000Z","updated":"2018-12-20T13:33:33.752Z","comments":true,"path":"2018/12/20/211. Add and Search Word - Data structure design/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/211. Add and Search Word - Data structure design/","excerpt":"","text":"211. Add and Search Word - Data structure design Design a data structure that supports the following two operations: 描述addWord(&quot;bad&quot;) addWord(&quot;dad&quot;) addWord(&quot;mad&quot;) search(&quot;pad&quot;) -&gt; false search(&quot;bad&quot;) -&gt; true search(&quot;.ad&quot;) -&gt; true search(&quot;b..&quot;) -&gt; true 代码class WordDictionary { private class Node{ public boolean isWord; public TreeMap&lt;Character,Node&gt; next; public Node(boolean isWord) { this.isWord=isWord; next=new TreeMap&lt;&gt;(); } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public WordDictionary() { root=new Node(); size=0; } /** Adds a word into the data structure. */ public void addWord(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { cur.next.put(c, new Node()); } cur=cur.next.get(c); } cur.isWord=true; size++; } /** Returns if the word is in the data structure. A word could contain the dot character &apos;.&apos; to represent any one letter. */ public boolean search(String word) { int i=0; Node cur=root; return recurtionSearch(i,word,cur); } private boolean recurtionSearch(int i,String str,Node cur) { if(i==str.length()) return cur.isWord; char m=str.charAt(i); if(m!=&apos;.&apos;) { if(cur.next.get(m)==null) return false; return recurtionSearch(++i, str,cur.next.get(m)); }else { //这个逻辑，就跳过点.这个位置 for(char c:cur.next.keySet()) if(recurtionSearch(++i, str,cur.next.get(c))) return true; return false; } } // public static void main(String[] args) { // WordDictionary wordDictionary = new WordDictionary(); // wordDictionary.addWord(&quot;123&quot;); // ; // System.out.println(wordDictionary.search(&quot;.3&quot;)); // } } /** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */","categories":[],"tags":[{"name":"leetcode Trie","slug":"leetcode-Trie","permalink":"https://jzygaga.github.io/tags/leetcode-Trie/"}]},{"title":"leetcode","slug":"leetcode-208. Implement Trie (Prefix Tree) - 副本","date":"2018-12-20T11:36:27.000Z","updated":"2019-01-02T05:33:20.270Z","comments":true,"path":"2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","link":"","permalink":"https://jzygaga.github.io/2018/12/20/leetcode-208. Implement Trie (Prefix Tree) - 副本/","excerpt":"","text":"208. Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. 描述Trie trie = new Trie();trie.insert(“apple”);trie.search(“apple”); // returns truetrie.search(“app”); // returns falsetrie.startsWith(“app”); // returns truetrie.insert(“app”);trie.search(“app”); // returns true * 代码class Trie { private class Node { public boolean isWord; public TreeMap&lt;Character, Node&gt; next; public Node(boolean isWord) { next = new TreeMap&lt;&gt;(); this.isWord = isWord; } public Node() { this(false); } } private Node root; private int size; /** Initialize your data structure here. */ public Trie() { root=new Node(); size=0; } /** Inserts a word into the trie. */ public void insert(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); Node node = cur.next.get(c); if(node==null) cur.next.put(c, new Node()); cur=cur.next.get(c); } cur.isWord=true; } /** Returns if the word is in the trie. */ public boolean search(String word) { Node cur=root; for(int i=0;i&lt;word.length();i++) { char c = word.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return cur.isWord; } /** * Returns if there is any word in the trie that starts with the given prefix. */ public boolean startsWith(String prefix) { Node cur=root; for(int i=0;i&lt;prefix.length();i++) { char c = prefix.charAt(i); if(cur.next.get(c)==null) { return false; } cur=cur.next.get(c); } return true; } // public static void main(String[] args) { // String[] arr= {&quot;Trie&quot;,&quot;insert&quot;,&quot;search&quot;,&quot;startWith&quot;,&quot;insert&quot;,&quot;search&quot;}; // Trie trie = new Trie(); // for(int i=0;i&lt;arr.length;i++) // trie.insert(arr[i]); // System.out.println(trie.startsWith(&quot;tr&quot;)); // System.out.println(trie.startsWith(&quot;in&quot;)); // System.out.println(trie.startsWith(&quot;sea&quot;)); // System.out.println(trie.search(&quot;Trie&quot;)); // System.out.println(trie.search(&quot;insert&quot;)); // System.out.println(trie.search(&quot;word&quot;)); // } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://jzygaga.github.io/categories/leetcode/"}],"tags":[{"name":"Trie","slug":"Trie","permalink":"https://jzygaga.github.io/tags/Trie/"}]},{"title":"递归入门","slug":"递归入门","date":"2018-12-16T09:01:40.000Z","updated":"2018-12-16T09:01:40.355Z","comments":true,"path":"2018/12/16/递归入门/","link":"","permalink":"https://jzygaga.github.io/2018/12/16/递归入门/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"多线程","slug":"多线程","date":"2018-12-14T05:53:05.000Z","updated":"2019-01-01T12:55:43.675Z","comments":true,"path":"2018/12/14/多线程/","link":"","permalink":"https://jzygaga.github.io/2018/12/14/多线程/","excerpt":"","text":"","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"https://jzygaga.github.io/tags/多线程/"}]},{"title":"capon","slug":"capon","date":"2018-12-05T06:26:05.000Z","updated":"2018-12-05T15:28:39.356Z","comments":true,"path":"2018/12/05/capon/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/capon/","excerpt":"","text":"哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa哒哒哒哒哒哒所多fdaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"https://jzygaga.github.io/tags/项目/"}]},{"title":"我滴妈","slug":"basic12","date":"2018-12-05T06:01:18.000Z","updated":"2018-12-08T18:28:23.052Z","comments":true,"path":"2018/12/05/basic12/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/basic12/","excerpt":"","text":"问题描述123321是一个非常特殊的数，它从左边读和从右边读是一样的。 输入一个正整数n， 编程求所有这样的五位和六位十进制数，满足各位数字之和等于n 。 输入格式 输入一行，包含一个正整数n。 输出格式 按从小到大的顺序输出满足条件的整数，每个整数占一行。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package algorithm.Lanqiao.基础练习; import java.util.Scanner; public class base9 { public static void main(String[] args) { int n; Scanner in = new Scanner(System.in); n = in.nextInt(); in.close(); //5位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } //6位的 for (int i = 1; i &lt; 10; i++) { for (int j = 0; j &lt; 10; j++) { for (int k = 0; k &lt; 10; k++) { if (i * 2 + j * 2 + k * 2 == n) { System.out.print(i); System.out.print(j); System.out.print(k); System.out.print(k); System.out.print(j); System.out.print(i); System.out.println(); } } } } }","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]},{"title":"我滴妈","slug":"蓝桥被入门题第一题","date":"2018-12-05T06:01:18.000Z","updated":"2018-12-08T16:08:25.969Z","comments":true,"path":"2018/12/05/蓝桥被入门题第一题/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/蓝桥被入门题第一题/","excerpt":"","text":"问题描述Fibonacci数列的递推公式为：Fn=Fn-1+Fn-2，其中F1=F2=1。 当n比较大时，Fn也非常大，现在我们想知道，Fn除以10007的余数是多少。 输入格式输入包含一个整数n。 输出格式输出一行，包含一个整数，表示Fn除以10007的余数。 说明：在本题中，答案是要求Fn除以10007的余数，因此我们只要能算出这个余数即可，而不需要先计算出Fn的准确值，再将计算的结果除以10007取余数，直接计算余数往往比先算出原数再取余简单。 package begin4; import java.util.Scanner; public class Main { public static void main(String[] args) { int[] f= new int[1000001]; f[1] = f[2] = 1; for (int i = 3; i &lt;= 1000000; i++) { f[i] = (f[i-1] + f[i-2]) % 10007; } Scanner in = new Scanner(System.in); System.out.println(f[in.nextInt()]); in.close(); } }","categories":[],"tags":[{"name":"蓝桥杯","slug":"蓝桥杯","permalink":"https://jzygaga.github.io/tags/蓝桥杯/"}]},{"title":"nihao,exo","slug":"nihao-exo","date":"2018-12-05T05:41:29.000Z","updated":"2018-12-05T05:41:29.959Z","comments":true,"path":"2018/12/05/nihao-exo/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/nihao-exo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-12-05T05:01:55.023Z","updated":"2018-12-05T05:01:55.023Z","comments":true,"path":"2018/12/05/hello-world/","link":"","permalink":"https://jzygaga.github.io/2018/12/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}